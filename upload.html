<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ä¸Šä¼ ç®¡ç† - picx-images-hosting</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hoochanlon/fonts@refs/heads/main/public/OPPOSans4/result.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="./style.css" />
  <style>
    .upload-page {
      min-height: 100vh;
      background: #f6f8fa;
    }

    .upload-header {
      background: #fff;
      border-bottom: 1px solid #d0d7de;
      padding: 16px 24px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .upload-header h1 {
      margin: 0;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .upload-header .back-link {
      color: #0969da;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .upload-header .back-link:hover {
      text-decoration: underline;
    }

    .upload-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px;
    }

    .upload-toolbar {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .upload-toolbar button {
      padding: 8px 16px;
      border: 1px solid #d0d7de;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .upload-toolbar button:hover {
      background: #f6f8fa;
    }

    .upload-toolbar .btn-primary {
      background: #0969da;
      color: #fff;
      border-color: #0969da;
    }

    .upload-toolbar .btn-primary:hover {
      background: #0860ca;
    }

    .breadcrumb {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .breadcrumb-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .breadcrumb-item a {
      color: #0969da;
      text-decoration: none;
    }

    .breadcrumb-item a:hover {
      text-decoration: underline;
      color: #0860ca;
    }
    
    .breadcrumb-item a {
      cursor: pointer;
    }

    .breadcrumb-separator {
      color: #8b949e;
    }

    .file-browser {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      overflow: hidden;
    }

    .file-list {
      list-style: none;
      margin: 0;
      padding: 0;
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid #f6f8fa;
      cursor: pointer;
    }

    .file-item:hover {
      background: #f6f8fa;
    }

    .file-item.selected {
      background: #e7f3ff;
    }

    .file-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b949e;
    }

    .file-name {
      flex: 1;
      font-size: 0.95rem;
      cursor: pointer;
      user-select: none;
    }

    .file-item .file-name:hover {
      color: #0969da;
    }

    .file-actions {
      display: flex;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .file-item:hover .file-actions {
      opacity: 1;
    }

    .file-actions button {
      padding: 4px 8px;
      border: 1px solid #d0d7de;
      background: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .file-actions button:hover {
      background: #f6f8fa;
    }

    .file-actions .btn-danger {
      color: #cf222e;
      border-color: #e6b0b0;
    }

    .file-actions .btn-danger:hover {
      background: #fff3f3;
    }

    .file-actions .btn-copy-pages {
      color: #0969da;
      border-color: #0969da;
    }

    .file-actions .btn-copy-pages:hover {
      background: #e8f1fd;
    }

    .file-actions .btn-copy-cdn {
      color: #117a37;
      border-color: #117a37;
    }

    .file-actions .btn-copy-cdn:hover {
      background: #e6fff5;
    }

    .file-name {
      cursor: pointer;
    }

    .upload-area {
      border: 2px dashed #d0d7de;
      border-radius: 8px;
      padding: 48px;
      text-align: center;
      background: #fafbfc;
      margin-bottom: 16px;
      transition: all 0.2s;
    }

    .upload-area.dragover {
      border-color: #0969da;
      background: #e7f3ff;
    }

    .upload-area-icon {
      font-size: 3rem;
      color: #8b949e;
      margin-bottom: 16px;
    }

    .upload-area-text {
      font-size: 1.1rem;
      color: #24292f;
      margin-bottom: 8px;
    }

    .upload-area-hint {
      font-size: 0.9rem;
      color: #57606a;
    }

    .upload-progress {
      margin-top: 16px;
    }

    .progress-item {
      background: #fff;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .progress-bar {
      flex: 1;
      height: 8px;
      background: #f6f8fa;
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #0969da;
      transition: width 0.3s;
    }

    .modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 2000;
      background: rgba(0, 0, 0, 0.5);
      align-items: center;
      justify-content: center;
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      min-width: 400px;
      max-width: 90vw;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.25rem;
    }

    .modal-close {
      border: none;
      background: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #8b949e;
    }

    .modal-body {
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 16px;
    }

    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
      font-size: 0.95rem;
    }

    .form-group input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      font-size: 0.95rem;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }

    .empty-state {
      text-align: center;
      padding: 48px;
      color: #8b949e;
    }

    .empty-state-icon {
      font-size: 3rem;
      margin-bottom: 16px;
    }
  </style>
</head>
<body class="upload-page">
  <header class="upload-header">
    <h1>
      <span>ğŸ–¼ï¸</span>
      <span>ä¸Šä¼ ç®¡ç†</span>
    </h1>
    <a href="index.html" class="back-link">
      <i class="fas fa-arrow-left"></i>
      è¿”å›é¦–é¡µ
    </a>
  </header>

  <div class="upload-container">
    <div class="upload-toolbar">
      <button id="create-folder-btn" class="btn-primary">
        <i class="fas fa-folder-plus"></i>
        æ–°å»ºæ–‡ä»¶å¤¹
      </button>
      <button id="upload-files-btn">
        <i class="fas fa-upload"></i>
        ä¸Šä¼ æ–‡ä»¶
      </button>
      <button id="upload-folder-btn">
        <i class="fas fa-folder-open"></i>
        ä¸Šä¼ æ–‡ä»¶å¤¹
      </button>
      <button id="settings-upload-path-btn" title="è®¾ç½®ä¸Šä¼ ç›®å½•">
        <i class="fas fa-cog"></i>
        è®¾ç½®ä¸Šä¼ ç›®å½•
      </button>
      <input type="file" id="file-input" multiple style="display: none;" />
      <input type="file" id="folder-input" webkitdirectory multiple style="display: none;" />
    </div>

    <div class="upload-area" id="upload-area">
      <div class="upload-area-icon">ğŸ“¤</div>
      <div class="upload-area-text">æ‹–æ‹½æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹åˆ°è¿™é‡Œä¸Šä¼ </div>
      <div class="upload-area-hint">æ”¯æŒå¤šæ–‡ä»¶ä¸Šä¼ </div>
    </div>

    <div class="breadcrumb" id="breadcrumb">
      <div class="breadcrumb-item">
        <a href="#" data-path="">æ ¹ç›®å½•</a>
      </div>
    </div>

    <div class="file-browser">
      <ul class="file-list" id="file-list">
        <li class="empty-state">
          <div class="empty-state-icon">ğŸ“</div>
          <div>æ­£åœ¨åŠ è½½...</div>
        </li>
      </ul>
    </div>

    <div class="upload-progress" id="upload-progress" style="display: none;"></div>
  </div>

  <!-- åˆ›å»ºæ–‡ä»¶å¤¹æ¨¡æ€æ¡† -->
  <div class="modal" id="create-folder-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>æ–°å»ºæ–‡ä»¶å¤¹</h2>
        <button class="modal-close" data-close="create-folder">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>æ–‡ä»¶å¤¹åç§°ï¼š</label>
          <input type="text" id="folder-name-input" placeholder="è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="create-folder">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-create-folder">åˆ›å»º</button>
      </div>
    </div>
  </div>

  <!-- è®¾ç½®ä¸Šä¼ ç›®å½•æ¨¡æ€æ¡† -->
  <div class="modal" id="settings-upload-path-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>è®¾ç½®ä¸Šä¼ ç›®å½•</h2>
        <button class="modal-close" data-close="settings-upload-path">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>ä¸Šä¼ ç›®å½•è·¯å¾„ï¼š</label>
          <input type="text" id="upload-path-input" placeholder="ä¾‹å¦‚: imgs/uploads/kate/" />
          <div style="margin-top: 10px; font-size: 12px; color: #666;">
            <p>æç¤ºï¼š</p>
            <ul style="margin: 5px 0; padding-left: 20px;">
              <li>ç•™ç©ºåˆ™ä½¿ç”¨å½“å‰æµè§ˆçš„ç›®å½•</li>
              <li>è·¯å¾„ä¼šè‡ªåŠ¨æ·»åŠ æœ«å°¾æ–œæ </li>
              <li>å¯ä»¥ä½¿ç”¨é¢åŒ…å±‘å¯¼èˆªé€‰æ‹©ç›®å½•åè®¾ç½®</li>
            </ul>
          </div>
        </div>
        <div class="form-group" style="margin-top: 15px;">
          <button class="btn-secondary" id="use-current-path-btn" style="margin-right: 10px;">ä½¿ç”¨å½“å‰ç›®å½•</button>
          <button class="btn-secondary" id="clear-upload-path-btn">æ¸…é™¤è®¾ç½®</button>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="settings-upload-path">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-settings-upload-path">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <!-- é‡å‘½åæ¨¡æ€æ¡† -->
  <div class="modal" id="rename-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>é‡å‘½å</h2>
        <button class="modal-close" data-close="rename">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>æ–°åç§°ï¼š</label>
          <input type="text" id="rename-input" placeholder="è¯·è¾“å…¥æ–°åç§°" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="rename">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-rename">ç¡®å®š</button>
      </div>
    </div>
  </div>

  <script>
    const REPO_OWNER = 'hoochanlon';
    const REPO_NAME = 'picx-images-hosting';
    const BRANCH = 'master';
    const PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}`;
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${REPO_OWNER}/${REPO_NAME}@${BRANCH}`;
    const IMAGE_EXT = /\.(jpe?g|png|gif|webp|svg)$/i;

    // è‡ªåŠ¨æ£€æµ‹ API åŸºç¡€åœ°å€
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isVercelDev = isLocalhost && window.location.port === '3000';
    const API_BASE = isLocalhost && !isVercelDev
      ? 'https://picx-images-hosting-brown.vercel.app' 
      : window.location.origin;
    const API_ENDPOINT = `${API_BASE}/api/github`;

    let currentPath = '';
    let files = [];
    let folders = [];

    // DOM å…ƒç´ 
    const fileListEl = document.getElementById('file-list');
    const breadcrumbEl = document.getElementById('breadcrumb');
    const uploadAreaEl = document.getElementById('upload-area');
    const fileInputEl = document.getElementById('file-input');
    const folderInputEl = document.getElementById('folder-input');
    const uploadProgressEl = document.getElementById('upload-progress');
    const createFolderBtn = document.getElementById('create-folder-btn');
    const uploadFilesBtn = document.getElementById('upload-files-btn');
    const uploadFolderBtn = document.getElementById('upload-folder-btn');
    const createFolderModal = document.getElementById('create-folder-modal');
    const renameModal = document.getElementById('rename-modal');
    const folderNameInput = document.getElementById('folder-name-input');
    const renameInput = document.getElementById('rename-input');

    // å·¥å…·å‡½æ•°
    async function toBase64(file) {
      const buffer = await file.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }

    async function apiRequest(payload) {
      try {
        const res = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        
        if (!res.ok) {
          let errorMessage = `API è¯·æ±‚å¤±è´¥: HTTP ${res.status}`;
          try {
            const errorData = await res.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
          } catch (e) {
            const text = await res.text().catch(() => '');
            if (text) errorMessage = text;
          }
          throw new Error(errorMessage);
        }
        
        return res.json();
      } catch (err) {
        // å¤„ç†ç½‘ç»œé”™è¯¯
        if (err.name === 'TypeError' && err.message.includes('fetch')) {
          throw new Error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•');
        }
        throw err;
      }
    }

    async function fetchTree() {
      const url = `${API_BASE}/api/tree`;
      const res = await fetch(url);
      if (!res.ok) {
        const body = await res.json().catch(() => ({}));
        const hint = body.message || `HTTP ${res.status}`;
        throw new Error(`è·å–ä»“åº“æ ‘å¤±è´¥ï¼š${hint}`);
      }
      return res.json();
    }

    function buildPath(...parts) {
      const filtered = parts.filter(p => p && p.trim());
      if (filtered.length === 0) return '';
      // ç¡®ä¿è·¯å¾„æ ¼å¼æ­£ç¡®ï¼Œç§»é™¤å¤šä½™çš„æ–œæ 
      let path = filtered.join('/').replace(/\/+/g, '/');
      // ç§»é™¤å¼€å¤´çš„æ–œæ ï¼ˆGitHub API ä¸éœ€è¦ï¼‰
      if (path.startsWith('/')) {
        path = path.substring(1);
      }
      return path;
    }

    function getParentPath(path) {
      if (!path) return '';
      const parts = path.split('/').filter(p => p);
      parts.pop();
      return parts.join('/');
    }

    function updateBreadcrumb(path) {
      breadcrumbEl.innerHTML = '';
      const parts = path ? path.split('/').filter(p => p) : [];
      
      // æ ¹ç›®å½•
      const rootItem = document.createElement('div');
      rootItem.className = 'breadcrumb-item';
      const rootLink = document.createElement('a');
      rootLink.href = 'javascript:void(0)';
      rootLink.textContent = 'æ ¹ç›®å½•';
      rootLink.dataset.path = '';
      rootLink.style.cursor = 'pointer';
      rootLink.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('ç‚¹å‡»æ ¹ç›®å½•');
        navigateTo('');
        return false;
      });
      rootItem.appendChild(rootLink);
      breadcrumbEl.appendChild(rootItem);

      // è·¯å¾„éƒ¨åˆ†
      let breadcrumbPath = '';
      parts.forEach((part, index) => {
        const separator = document.createElement('span');
        separator.className = 'breadcrumb-separator';
        separator.textContent = ' / ';
        breadcrumbEl.appendChild(separator);

        breadcrumbPath = buildPath(breadcrumbPath, part);
        const item = document.createElement('div');
        item.className = 'breadcrumb-item';
        const link = document.createElement('a');
        link.href = 'javascript:void(0)';
        link.textContent = part;
        link.dataset.path = breadcrumbPath;
        link.style.cursor = 'pointer';
        
        // ä½¿ç”¨é—­åŒ…ä¿å­˜ breadcrumbPath çš„å€¼
        (function(path) {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('ç‚¹å‡»é¢åŒ…å±‘ç›®å½•:', part, 'è·¯å¾„:', path);
            console.log('å‡†å¤‡å¯¼èˆªï¼Œå½“å‰è·¯å¾„:', currentPath);
            navigateTo(path);
            return false;
          });
        })(breadcrumbPath);
        item.appendChild(link);
        breadcrumbEl.appendChild(item);
      });
    }

    function navigateTo(path) {
      console.log('å¯¼èˆªåˆ°è·¯å¾„:', path);
      console.log('å½“å‰è·¯å¾„ (å¯¼èˆªå‰):', currentPath);
      const normalizedPath = (path || '').trim();
      currentPath = normalizedPath;
      console.log('å½“å‰è·¯å¾„ (å¯¼èˆªå):', currentPath);
      updateBreadcrumb(currentPath);
      // ä½¿ç”¨ setTimeout ç¡®ä¿ currentPath å·²ç»æ›´æ–°
      setTimeout(() => {
        console.log('å¼€å§‹åŠ è½½æ–‡ä»¶ï¼Œå½“å‰è·¯å¾„åº”è¯¥æ˜¯:', currentPath);
        loadFiles();
      }, 0);
    }

    function renderFiles() {
      fileListEl.innerHTML = '';
      
      if (folders.length === 0 && files.length === 0) {
        fileListEl.innerHTML = `
          <li class="empty-state">
            <div class="empty-state-icon">ğŸ“</div>
            <div>å½“å‰ç›®å½•ä¸ºç©º</div>
          </li>
        `;
        return;
      }

      // æ˜¾ç¤ºæ–‡ä»¶å¤¹
      folders.forEach(folder => {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.innerHTML = `
          <div class="file-icon"><i class="fas fa-folder"></i></div>
          <div class="file-name">${folder.name}</div>
          <div class="file-actions">
            <button class="btn-rename" data-type="folder" data-path="${folder.path}" title="é‡å‘½å">
              <i class="fas fa-edit"></i>
            </button>
            <button class="btn-delete btn-danger" data-type="folder" data-path="${folder.path}" title="åˆ é™¤">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        li.querySelector('.file-name').addEventListener('click', () => {
          navigateTo(folder.path);
        });
        
        li.querySelector('.btn-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          showRenameModal('folder', folder.path, folder.name);
        });
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteItem('folder', folder.path);
        });
        
        fileListEl.appendChild(li);
      });

      // æ˜¾ç¤ºæ–‡ä»¶
      files.forEach(file => {
        const li = document.createElement('li');
        li.className = 'file-item';
        const isImage = IMAGE_EXT.test(file.name);
        const pagesUrl = `${PAGES_BASE}/${file.path}`;
        const cdnUrl = `${CDN_BASE}/${file.path}`;
        
        li.innerHTML = `
          <div class="file-icon">
            <i class="fas ${isImage ? 'fa-image' : 'fa-file'}"></i>
          </div>
          <div class="file-name">${file.name}</div>
          <div class="file-actions">
            <button class="btn-copy-pages" data-url="${pagesUrl}" title="å¤åˆ¶ Pages é“¾æ¥">
              <i class="fas fa-link"></i>
            </button>
            <button class="btn-copy-cdn" data-url="${cdnUrl}" title="å¤åˆ¶ CDN é“¾æ¥">
              <i class="fas fa-cloud"></i>
            </button>
            <button class="btn-rename" data-type="file" data-path="${file.path}" title="é‡å‘½å">
              <i class="fas fa-edit"></i>
            </button>
            <button class="btn-delete btn-danger" data-type="file" data-path="${file.path}" title="åˆ é™¤">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        // å¤åˆ¶ Pages é“¾æ¥
        li.querySelector('.btn-copy-pages').addEventListener('click', async (e) => {
          e.stopPropagation();
          const url = li.querySelector('.btn-copy-pages').dataset.url;
          try {
            await navigator.clipboard.writeText(url);
            const btn = li.querySelector('.btn-copy-pages');
            const originalTitle = btn.title;
            btn.title = 'å·²å¤åˆ¶';
            setTimeout(() => {
              btn.title = originalTitle;
            }, 1500);
          } catch (err) {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
          }
        });
        
        // å¤åˆ¶ CDN é“¾æ¥
        li.querySelector('.btn-copy-cdn').addEventListener('click', async (e) => {
          e.stopPropagation();
          const url = li.querySelector('.btn-copy-cdn').dataset.url;
          try {
            await navigator.clipboard.writeText(url);
            const btn = li.querySelector('.btn-copy-cdn');
            const originalTitle = btn.title;
            btn.title = 'å·²å¤åˆ¶';
            setTimeout(() => {
              btn.title = originalTitle;
            }, 1500);
          } catch (err) {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
          }
        });
        
        li.querySelector('.btn-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          showRenameModal('file', file.path, file.name);
        });
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteItem('file', file.path);
        });
        
        fileListEl.appendChild(li);
      });
    }

    async function loadFiles() {
      try {
        fileListEl.innerHTML = '<li class="empty-state"><div>æ­£åœ¨åŠ è½½...</div></li>';
        const tree = await fetchTree();
        
        const allItems = (tree.tree || []).filter(item => item.type === 'blob' || item.type === 'tree');
        
        folders = [];
        files = [];
        
        console.log('åŠ è½½æ–‡ä»¶ï¼Œå½“å‰è·¯å¾„:', currentPath);
        allItems.forEach(item => {
          const itemPath = item.path;
          const itemDir = itemPath.includes('/') ? itemPath.slice(0, itemPath.lastIndexOf('/')) : '';
          
          // ç¡®ä¿è·¯å¾„æ¯”è¾ƒæ—¶éƒ½ä½¿ç”¨è§„èŒƒåŒ–æ ¼å¼ï¼ˆæ— å‰åæ–œæ ï¼‰
          const normalizedCurrentPath = (currentPath || '').trim();
          const normalizedItemDir = (itemDir || '').trim();
          
          console.log(`æ£€æŸ¥é¡¹ç›®: ${itemPath}, é¡¹ç›®ç›®å½•: "${normalizedItemDir}", å½“å‰è·¯å¾„: "${normalizedCurrentPath}"`);
          
          if (normalizedItemDir === normalizedCurrentPath) {
            if (item.type === 'tree') {
              folders.push({
                name: itemPath.split('/').pop(),
                path: itemPath
              });
            } else {
              files.push({
                name: itemPath.split('/').pop(),
                path: itemPath
              });
            }
          }
        });
        
        console.log('æ‰¾åˆ°çš„æ–‡ä»¶å¤¹:', folders.length, 'ä¸ª');
        console.log('æ‰¾åˆ°çš„æ–‡ä»¶:', files.length, 'ä¸ª');
        
        folders.sort((a, b) => a.name.localeCompare(b.name));
        files.sort((a, b) => a.name.localeCompare(b.name));
        
        renderFiles();
      } catch (err) {
        console.error(err);
        fileListEl.innerHTML = `
          <li class="empty-state">
            <div class="empty-state-icon">âŒ</div>
            <div>åŠ è½½å¤±è´¥ï¼š${err.message}</div>
          </li>
        `;
      }
    }

    async function createFolder(name) {
      if (!name || !name.trim()) {
        alert('è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°');
        return;
      }
      
      const folderPath = buildPath(currentPath, name.trim());
      const folderPathWithSlash = folderPath.endsWith('/') ? folderPath : folderPath + '/';
      
      // åˆ›å»º .gitkeep æ–‡ä»¶æ¥åˆ›å»ºæ–‡ä»¶å¤¹
      const content = btoa('');
      try {
        await apiRequest({
          action: 'upload',
          path: `${folderPathWithSlash}.gitkeep`,
          content: content,
          message: `Create folder: ${folderPath}`
        });
        
        // åˆ é™¤ .gitkeep æ–‡ä»¶ï¼ˆGitHub ä¼šè‡ªåŠ¨ä¿ç•™ç©ºæ–‡ä»¶å¤¹ï¼‰
        // å®é™…ä¸Š GitHub ä¸æ”¯æŒç©ºæ–‡ä»¶å¤¹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¿ç•™ .gitkeep
        // æˆ–è€…åˆ›å»ºä¸€ä¸ª README.md
        
        loadFiles();
        closeModal('create-folder');
        folderNameInput.value = '';
      } catch (err) {
        console.error(err);
        alert('åˆ›å»ºæ–‡ä»¶å¤¹å¤±è´¥ï¼š' + err.message);
      }
    }

    // ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆé€šè¿‡åˆ›å»º .gitkeep æ–‡ä»¶ï¼‰
    async function ensureDirectoryExists(dirPath) {
      if (!dirPath || dirPath === '') return;
      
      // è§„èŒƒåŒ–è·¯å¾„ï¼šç§»é™¤å¼€å¤´çš„æ–œæ 
      let normalizedPath = dirPath.trim();
      if (normalizedPath.startsWith('/')) {
        normalizedPath = normalizedPath.substring(1);
      }
      
      // åˆ†å‰²è·¯å¾„ä¸ºå„ä¸ªéƒ¨åˆ†
      const parts = normalizedPath.split('/').filter(p => p);
      if (parts.length === 0) return;
      
      // é€’å½’åˆ›å»ºæ‰€æœ‰çˆ¶ç›®å½•
      let currentPath = '';
      for (let i = 0; i < parts.length; i++) {
        currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
        const gitkeepPath = `${currentPath}/.gitkeep`;
        
        // æ£€æŸ¥ç›®å½•æ˜¯å¦å·²å­˜åœ¨
        let dirExists = false;
        try {
          const checkRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
          if (checkRes.ok) {
            dirExists = true;
          }
        } catch (e) {
          // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ›å»º
        }
        
        if (dirExists) {
          // ç›®å½•å·²å­˜åœ¨ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
          continue;
        }
        
        // å¦‚æœå½“å‰ä¸æ˜¯ç¬¬ä¸€ä¸ªç›®å½•ï¼Œç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
        if (i > 0) {
          const parentPath = parts.slice(0, i).join('/');
          await ensureDirectoryExists(parentPath);
        }
        
        // åˆ›å»º .gitkeep æ–‡ä»¶æ¥ç¡®ä¿ç›®å½•å­˜åœ¨
        try {
          console.log(`åˆ›å»ºç›®å½• ${currentPath}ï¼Œè·¯å¾„: ${gitkeepPath}`);
          const createResult = await apiRequest({
            action: 'upload',
            path: gitkeepPath,
            content: btoa(''),
            message: `Create directory: ${currentPath}/`
          });
          console.log(`ç›®å½• ${currentPath} åˆ›å»ºAPIè°ƒç”¨æˆåŠŸ:`, createResult);
          
          // éªŒè¯ç›®å½•æ˜¯å¦çœŸæ­£åˆ›å»ºæˆåŠŸ
          let verified = false;
          for (let retry = 0; retry < 5; retry++) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1))); // ç­‰å¾… API ç”Ÿæ•ˆ
            try {
              const verifyRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
              console.log(`éªŒè¯ç›®å½• ${currentPath}ï¼Œå°è¯• ${retry + 1}/5ï¼ŒçŠ¶æ€: ${verifyRes.status}`);
              if (verifyRes.ok) {
                verified = true;
                console.log(`ç›®å½• ${currentPath} éªŒè¯æˆåŠŸ`);
                break;
              }
            } catch (e) {
              console.log(`éªŒè¯ç›®å½• ${currentPath} å¤±è´¥:`, e);
            }
          }
          
          if (!verified) {
            console.error(`ç›®å½• ${currentPath} åˆ›å»ºåéªŒè¯å¤±è´¥`);
            throw new Error(`ç›®å½•åˆ›å»ºåéªŒè¯å¤±è´¥: ${currentPath}`);
          }
        } catch (err) {
          console.error(`Failed to create directory ${currentPath}:`, err);
          const errorMsg = err.message || '';
          // å¦‚æœé”™è¯¯æ˜¯ç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•å†æ¬¡åˆ›å»ºçˆ¶ç›®å½•
          if (errorMsg.includes('not be found') && i > 0) {
            const parentPath = parts.slice(0, i).join('/');
            await ensureDirectoryExists(parentPath);
            // å†æ¬¡é‡è¯•
            await apiRequest({
              action: 'upload',
              path: gitkeepPath,
              content: btoa(''),
              message: `Create directory: ${currentPath}/`
            });
          } else {
            throw new Error(`æ— æ³•åˆ›å»ºç›®å½• ${currentPath}: ${errorMsg || 'æœªçŸ¥é”™è¯¯'}`);
          }
        }
      }
    }

    // è·å–å’Œä¿å­˜ä¸Šä¼ ç›®å½•è®¾ç½®
    function getUploadPath() {
      const saved = localStorage.getItem('uploadPath');
      return saved || '';
    }

    function saveUploadPath(path) {
      if (path && path.trim()) {
        localStorage.setItem('uploadPath', path.trim());
      } else {
        localStorage.removeItem('uploadPath');
      }
    }

    async function uploadFiles(fileList, basePath = '') {
      // ä¼˜å…ˆçº§ï¼šbasePath > è®¾ç½®çš„ä¸Šä¼ ç›®å½• > å½“å‰æµè§ˆç›®å½• > é»˜è®¤ç›®å½•
      let targetPath = basePath || getUploadPath() || currentPath || 'imgs/uploads/kate/';
      // ç¡®ä¿è·¯å¾„æ ¼å¼æ­£ç¡®
      if (targetPath && !targetPath.endsWith('/')) {
        targetPath += '/';
      }
      const filesArray = Array.from(fileList);
      
      if (filesArray.length === 0) return;
      
      uploadProgressEl.style.display = 'block';
      uploadProgressEl.innerHTML = '';
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼ˆæœ‰ webkitRelativePathï¼‰
      const isFolderUpload = filesArray.some(file => file.webkitRelativePath);
      
      // å¦‚æœæ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œå…ˆæ”¶é›†æ‰€æœ‰éœ€è¦çš„ç›®å½•å¹¶åˆ›å»º
      if (isFolderUpload) {
        console.log('æ£€æµ‹åˆ°æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œå…ˆåˆ›å»ºæ‰€æœ‰ç›®å½•...');
        const dirsToCreate = new Set();
        
        // æ”¶é›†æ‰€æœ‰éœ€è¦çš„ç›®å½•
        filesArray.forEach(file => {
          if (file.webkitRelativePath) {
            const filePath = buildPath(targetPath, file.webkitRelativePath);
            const fileDir = getParentPath(filePath);
            if (fileDir && fileDir !== '') {
              // æ”¶é›†æ‰€æœ‰çˆ¶ç›®å½•
              const dirParts = fileDir.split('/').filter(p => p);
              let currentDir = '';
              dirParts.forEach(part => {
                currentDir = currentDir ? `${currentDir}/${part}` : part;
                dirsToCreate.add(currentDir);
              });
            }
          }
        });
        
        // æŒ‰è·¯å¾„æ·±åº¦æ’åºï¼Œç¡®ä¿å…ˆåˆ›å»ºçˆ¶ç›®å½•
        const sortedDirs = Array.from(dirsToCreate).sort((a, b) => {
          const depthA = a.split('/').length;
          const depthB = b.split('/').length;
          return depthA - depthB;
        });
        
        console.log('éœ€è¦åˆ›å»ºçš„ç›®å½•:', sortedDirs);
        
        // åˆ›å»ºæ‰€æœ‰ç›®å½•
        for (const dir of sortedDirs) {
          console.log('åˆ›å»ºç›®å½•:', dir);
          await ensureDirectoryExists(dir);
        }
        
        console.log('æ‰€æœ‰ç›®å½•åˆ›å»ºå®Œæˆï¼Œç­‰å¾…ç”Ÿæ•ˆ...');
        // ç­‰å¾…ç›®å½•ç”Ÿæ•ˆ
        await new Promise(resolve => setTimeout(resolve, 3000));
        console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶...');
      }
      
      for (let i = 0; i < filesArray.length; i++) {
        const file = filesArray[i];
        const progressItem = document.createElement('div');
        progressItem.className = 'progress-item';
        const displayName = file.webkitRelativePath || file.name;
        progressItem.innerHTML = `
          <div class="file-name">${displayName}</div>
          <div class="progress-bar">
            <div class="progress-fill" style="width: 0%"></div>
          </div>
          <div class="progress-text">0%</div>
        `;
        uploadProgressEl.appendChild(progressItem);
        
        const progressFill = progressItem.querySelector('.progress-fill');
        const progressText = progressItem.querySelector('.progress-text');
        
        try {
          const content = await toBase64(file);
          
          // æ„å»ºæ–‡ä»¶è·¯å¾„
          let filePath;
          if (file.webkitRelativePath) {
            // æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„
            filePath = buildPath(targetPath, file.webkitRelativePath);
          } else {
            // æ™®é€šæ–‡ä»¶ä¸Šä¼ 
            filePath = buildPath(targetPath, file.name);
          }
          
          if (!filePath) {
            throw new Error('æ–‡ä»¶è·¯å¾„ä¸èƒ½ä¸ºç©º');
          }
          
          // å¦‚æœä¸æ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
          if (!isFolderUpload) {
            const fileDir = getParentPath(filePath);
            if (fileDir && fileDir !== '') {
              console.log('ç¡®ä¿ç›®å½•å­˜åœ¨:', fileDir);
              await ensureDirectoryExists(fileDir);
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
          }
          
          console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶:', filePath);
          
          // ç›´æ¥è°ƒç”¨ API ä»¥è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
          const uploadRes = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'upload',
              path: filePath,
              content: content,
              message: `Upload: ${filePath}`
            }),
          });
          
          if (!uploadRes.ok) {
            const errorData = await uploadRes.json().catch(() => ({}));
            console.error('ä¸Šä¼ å¤±è´¥ï¼ŒAPI å“åº”:', errorData);
            const errorMsg = errorData.message || errorData.error || `HTTP ${uploadRes.status}`;
            throw new Error(errorMsg);
          }
          
          const uploadResult = await uploadRes.json();
          console.log('ä¸Šä¼ æˆåŠŸ:', uploadResult);
          
          progressFill.style.width = '100%';
          progressText.textContent = 'å®Œæˆ';
          progressItem.style.opacity = '0.6';
        } catch (err) {
          console.error('ä¸Šä¼ å¤±è´¥:', err);
          // æä¾›æ›´å‹å¥½çš„é”™è¯¯æç¤º
          let errorMsg = err.message || 'ä¸Šä¼ å¤±è´¥';
          if (errorMsg.includes('not be found')) {
            // å°è¯•åˆ›å»ºç›®å½•åé‡è¯•
            try {
              const fileDir = getParentPath(buildPath(targetPath, file.webkitRelativePath || file.name));
              if (fileDir) {
                console.log('å°è¯•åˆ›å»ºç›®å½•:', fileDir);
                await ensureDirectoryExists(fileDir);
                console.log('ç›®å½•åˆ›å»ºæˆåŠŸï¼ŒéªŒè¯ç›®å½•å­˜åœ¨...');
                
                // éªŒè¯ç›®å½•ç¡®å®å­˜åœ¨
                const gitkeepPath = `${fileDir}/.gitkeep`;
                console.log('éªŒè¯ç›®å½•ï¼Œæ£€æŸ¥è·¯å¾„:', gitkeepPath);
                let dirVerified = false;
                for (let verifyRetry = 0; verifyRetry < 5; verifyRetry++) {
                  await new Promise(resolve => setTimeout(resolve, 2000 * (verifyRetry + 1))); // å¢åŠ ç­‰å¾…æ—¶é—´
                  try {
                    const verifyRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
                    console.log(`éªŒè¯å°è¯• ${verifyRetry + 1}/5ï¼ŒçŠ¶æ€: ${verifyRes.status}`);
                    if (verifyRes.ok) {
                      dirVerified = true;
                      console.log('ç›®å½•éªŒè¯æˆåŠŸï¼Œå¼€å§‹é‡è¯•ä¸Šä¼ ');
                      break;
                    } else {
                      const errorData = await verifyRes.json().catch(() => ({}));
                      console.log('éªŒè¯å¤±è´¥ï¼Œå“åº”:', errorData);
                    }
                  } catch (e) {
                    console.log(`ç›®å½•éªŒè¯é‡è¯• ${verifyRetry + 1}/5ï¼Œé”™è¯¯:`, e);
                  }
                }
                
                if (!dirVerified) {
                  throw new Error('ç›®å½•åˆ›å»ºåéªŒè¯å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
                }
                
                // å†æ¬¡ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆå¯èƒ½æ–‡ä»¶è·¯å¾„ä¸­æœ‰å­ç›®å½•ï¼‰
                const retryFilePath = buildPath(targetPath, file.webkitRelativePath || file.name);
                console.log('é‡è¯•æ–‡ä»¶è·¯å¾„:', retryFilePath);
                const retryFileDir = getParentPath(retryFilePath);
                console.log('é‡è¯•æ–‡ä»¶ç›®å½•:', retryFileDir);
                
                // ç¡®ä¿ç›®å½•å­˜åœ¨
                if (retryFileDir) {
                  if (retryFileDir !== fileDir) {
                    console.log('æ£€æµ‹åˆ°å­ç›®å½•ï¼Œç¡®ä¿å­ç›®å½•å­˜åœ¨:', retryFileDir);
                    await ensureDirectoryExists(retryFileDir);
                  }
                  
                  // å†æ¬¡éªŒè¯ç›®å½•å­˜åœ¨ï¼Œå¹¶ç­‰å¾…æ›´é•¿æ—¶é—´
                  const retryGitkeepPath = `${retryFileDir}/.gitkeep`;
                  console.log('é‡è¯•å‰å†æ¬¡éªŒè¯ç›®å½•:', retryGitkeepPath);
                  let retryDirVerified = false;
                  for (let retryVerify = 0; retryVerify < 5; retryVerify++) {
                    await new Promise(resolve => setTimeout(resolve, 2000 * (retryVerify + 1)));
                    try {
                      const retryVerifyRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(retryGitkeepPath)}`);
                      console.log(`é‡è¯•éªŒè¯å°è¯• ${retryVerify + 1}/5ï¼ŒçŠ¶æ€: ${retryVerifyRes.status}`);
                      if (retryVerifyRes.ok) {
                        retryDirVerified = true;
                        console.log('é‡è¯•å‰ç›®å½•éªŒè¯æˆåŠŸ');
                        break;
                      }
                    } catch (e) {
                      console.log(`é‡è¯•éªŒè¯å¤±è´¥:`, e);
                    }
                  }
                  
                  if (!retryDirVerified) {
                    throw new Error('é‡è¯•å‰ç›®å½•éªŒè¯å¤±è´¥');
                  }
                  
                  // é¢å¤–ç­‰å¾…ï¼Œç¡®ä¿ç›®å½•å®Œå…¨ç”Ÿæ•ˆ
                  console.log('ç­‰å¾…ç›®å½•å®Œå…¨ç”Ÿæ•ˆ...');
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  
                  // å°è¯•é€šè¿‡åˆ—å‡ºç›®å½•å†…å®¹æ¥éªŒè¯ç›®å½•æ˜¯å¦çœŸæ­£å¯ç”¨
                  console.log('å°è¯•åˆ—å‡ºç›®å½•å†…å®¹ä»¥éªŒè¯ç›®å½•å¯ç”¨æ€§...');
                  try {
                    const treeRes = await fetch(`${API_BASE}/api/tree`);
                    if (treeRes.ok) {
                      const treeData = await treeRes.json();
                      const dirFiles = (treeData.tree || []).filter(item => 
                        item.path.startsWith(retryFileDir + '/') && item.type === 'blob'
                      );
                      console.log(`ç›®å½• ${retryFileDir} ä¸­å·²æœ‰ ${dirFiles.length} ä¸ªæ–‡ä»¶ï¼Œç›®å½•å¯ç”¨`);
                    }
                  } catch (treeErr) {
                    console.warn('æ— æ³•åˆ—å‡ºç›®å½•å†…å®¹:', treeErr);
                  }
                }
                
                console.log('é‡è¯•ä¸Šä¼ æ–‡ä»¶:', retryFilePath);
                const retryContent = await toBase64(file);
                
                // ç›´æ¥è°ƒç”¨ API ä»¥è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                try {
                  const uploadRes = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      action: 'upload',
                      path: retryFilePath,
                      content: retryContent,
                      message: `Upload: ${retryFilePath}`
                    }),
                  });
                  
                  if (!uploadRes.ok) {
                    const errorData = await uploadRes.json().catch(() => ({}));
                    console.error('ä¸Šä¼ å¤±è´¥ï¼ŒAPI å“åº”:', errorData);
                    console.error('ä¸Šä¼ è·¯å¾„:', retryFilePath);
                    console.error('HTTP çŠ¶æ€:', uploadRes.status);
                    const errorMsg = errorData.message || errorData.error || `HTTP ${uploadRes.status}`;
                    throw new Error(errorMsg);
                  }
                  
                  const uploadResult = await uploadRes.json();
                  console.log('ä¸Šä¼ æˆåŠŸ:', uploadResult);
                } catch (uploadErr) {
                  console.error('ä¸Šä¼ å¼‚å¸¸:', uploadErr);
                  throw uploadErr;
                }
                progressFill.style.width = '100%';
                progressText.textContent = 'å®Œæˆ';
                progressItem.style.opacity = '0.6';
                continue; // æˆåŠŸï¼Œç»§ç»­ä¸‹ä¸€ä¸ªæ–‡ä»¶
              }
            } catch (retryErr) {
              console.error('ç›®å½•åˆ›å»ºæˆ–é‡è¯•ä¸Šä¼ å¤±è´¥:', retryErr);
              errorMsg = `ç›®å½•åˆ›å»ºå¤±è´¥: ${retryErr.message || 'è¯·æ£€æŸ¥è·¯å¾„æ˜¯å¦æ­£ç¡®'}`;
            }
          } else if (errorMsg.includes('already exists')) {
            errorMsg = 'æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯·é‡å‘½ååé‡è¯•';
          }
          progressText.textContent = 'å¤±è´¥ï¼š' + errorMsg;
          progressItem.style.color = '#cf222e';
        }
      }
      
      setTimeout(() => {
        loadFiles();
        setTimeout(() => {
          uploadProgressEl.style.display = 'none';
          uploadProgressEl.innerHTML = '';
        }, 2000);
      }, 1000);
    }

    function showRenameModal(type, path, currentName) {
      renameInput.value = currentName;
      renameInput.dataset.type = type;
      renameInput.dataset.path = path;
      showModal('rename');
    }

    async function renameItem(type, oldPath, newName) {
      if (!newName || !newName.trim()) {
        alert('è¯·è¾“å…¥æ–°åç§°');
        return;
      }
      
      const parentPath = getParentPath(oldPath);
      const newPath = buildPath(parentPath, newName.trim());
      
      if (type === 'folder') {
        // æ–‡ä»¶å¤¹é‡å‘½åéœ€è¦ç§»åŠ¨æ‰€æœ‰æ–‡ä»¶
        alert('æ–‡ä»¶å¤¹é‡å‘½ååŠŸèƒ½éœ€è¦ç§»åŠ¨æ‰€æœ‰æ–‡ä»¶ï¼Œæ­¤åŠŸèƒ½è¾ƒå¤æ‚ï¼Œå»ºè®®æ‰‹åŠ¨æ“ä½œ');
        return;
      }
      
      try {
        // è·å–åŸæ–‡ä»¶å†…å®¹
        const fileRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(oldPath)}`);
        const fileData = await fileRes.json();
        
        // åˆ›å»ºæ–°æ–‡ä»¶
        await apiRequest({
          action: 'upload',
          path: newPath,
          content: fileData.content,
          message: `Rename: ${oldPath} -> ${newPath}`
        });
        
        // åˆ é™¤åŸæ–‡ä»¶
        await apiRequest({
          action: 'delete',
          path: oldPath,
          sha: fileData.sha,
          message: `Delete old file: ${oldPath}`
        });
        
        loadFiles();
        closeModal('rename');
      } catch (err) {
        console.error(err);
        alert('é‡å‘½åå¤±è´¥ï¼š' + err.message);
      }
    }

    async function deleteItem(type, path) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤${type === 'folder' ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶'} "${path}" å—ï¼Ÿ`)) {
        return;
      }
      
      try {
        if (type === 'file') {
          // è·å–æ–‡ä»¶ä¿¡æ¯
          const fileRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(path)}`);
          if (!fileRes.ok) {
            const errorData = await fileRes.json().catch(() => ({}));
            throw new Error(errorData.message || `è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: HTTP ${fileRes.status}`);
          }
          
          const fileData = await fileRes.json();
          if (!fileData.sha) {
            throw new Error('æ— æ³•è·å–æ–‡ä»¶ SHAï¼Œæ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨');
          }
          
          // æ‰§è¡Œåˆ é™¤
          await apiRequest({
            action: 'delete',
            path: path,
            sha: fileData.sha,
            message: `Delete: ${path}`
          });
        } else {
          alert('æ–‡ä»¶å¤¹åˆ é™¤åŠŸèƒ½éœ€è¦åˆ é™¤æ‰€æœ‰æ–‡ä»¶ï¼Œæ­¤åŠŸèƒ½è¾ƒå¤æ‚ï¼Œå»ºè®®æ‰‹åŠ¨æ“ä½œ');
          return;
        }
        
        loadFiles();
      } catch (err) {
        console.error('åˆ é™¤å¤±è´¥:', err);
        const errorMessage = err.message || 'åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•';
        alert('åˆ é™¤å¤±è´¥ï¼š' + errorMessage);
      }
    }

    function showModal(modalId) {
      document.getElementById(`${modalId}-modal`).classList.add('show');
    }

    function closeModal(modalId) {
      document.getElementById(`${modalId}-modal`).classList.remove('show');
    }

    // äº‹ä»¶ç›‘å¬
    createFolderBtn.addEventListener('click', () => {
      folderNameInput.value = '';
      showModal('create-folder');
    });

    document.getElementById('confirm-create-folder').addEventListener('click', () => {
      createFolder(folderNameInput.value);
    });

    document.getElementById('confirm-rename').addEventListener('click', () => {
      const type = renameInput.dataset.type;
      const path = renameInput.dataset.path;
      renameItem(type, path, renameInput.value);
    });

    uploadFilesBtn.addEventListener('click', () => {
      fileInputEl.click();
    });

    uploadFolderBtn.addEventListener('click', () => {
      folderInputEl.click();
    });

    // è®¾ç½®ä¸Šä¼ ç›®å½•ç›¸å…³
    const settingsUploadPathBtn = document.getElementById('settings-upload-path-btn');
    const uploadPathInput = document.getElementById('upload-path-input');
    const useCurrentPathBtn = document.getElementById('use-current-path-btn');
    const clearUploadPathBtn = document.getElementById('clear-upload-path-btn');
    const confirmSettingsUploadPathBtn = document.getElementById('confirm-settings-upload-path');

    function saveUploadPath(path) {
      if (path && path.trim()) {
        localStorage.setItem('uploadPath', path.trim());
      } else {
        localStorage.removeItem('uploadPath');
      }
    }

    // åŠ è½½ä¿å­˜çš„ä¸Šä¼ ç›®å½•è®¾ç½®
    const savedUploadPath = getUploadPath();
    if (savedUploadPath && uploadPathInput) {
      uploadPathInput.value = savedUploadPath;
    }

    if (settingsUploadPathBtn) {
      settingsUploadPathBtn.addEventListener('click', () => {
        // æ‰“å¼€æ¨¡æ€æ¡†æ—¶ï¼Œæ˜¾ç¤ºå½“å‰è®¾ç½®æˆ–å½“å‰æµè§ˆçš„ç›®å½•
        const currentSaved = getUploadPath();
        if (uploadPathInput) {
          uploadPathInput.value = currentSaved || currentPath || '';
        }
        showModal('settings-upload-path');
      });
    }

    if (useCurrentPathBtn) {
      useCurrentPathBtn.addEventListener('click', () => {
        if (uploadPathInput) {
          uploadPathInput.value = currentPath || '';
        }
      });
    }

    if (clearUploadPathBtn) {
      clearUploadPathBtn.addEventListener('click', () => {
        if (uploadPathInput) {
          uploadPathInput.value = '';
        }
        saveUploadPath('');
        alert('å·²æ¸…é™¤ä¸Šä¼ ç›®å½•è®¾ç½®');
      });
    }

    if (confirmSettingsUploadPathBtn) {
      confirmSettingsUploadPathBtn.addEventListener('click', () => {
        const path = uploadPathInput ? uploadPathInput.value.trim() : '';
        saveUploadPath(path);
        closeModal('settings-upload-path');
        alert('ä¸Šä¼ ç›®å½•è®¾ç½®å·²ä¿å­˜ï¼š' + (path || 'ä½¿ç”¨å½“å‰æµè§ˆç›®å½•'));
      });
    }

    fileInputEl.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        uploadFiles(e.target.files);
        e.target.value = '';
      }
    });

    folderInputEl.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        uploadFiles(e.target.files, currentPath || 'imgs/uploads/kate/');
        e.target.value = '';
      }
    });

    // æ‹–æ‹½ä¸Šä¼ 
    uploadAreaEl.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadAreaEl.classList.add('dragover');
    });

    uploadAreaEl.addEventListener('dragleave', () => {
      uploadAreaEl.classList.remove('dragover');
    });

    uploadAreaEl.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadAreaEl.classList.remove('dragover');
      
      const files = Array.from(e.dataTransfer.files);
      if (files.length > 0) {
        uploadFiles(files);
      }
    });

    // æ¨¡æ€æ¡†å…³é—­
    document.querySelectorAll('[data-close]').forEach(btn => {
      btn.addEventListener('click', () => {
        const modalId = btn.dataset.close;
        closeModal(modalId);
      });
    });

    // åˆå§‹åŒ–
    // ç¡®ä¿åˆå§‹é¢åŒ…å±‘æ­£ç¡®è®¾ç½®
    updateBreadcrumb(currentPath);
    loadFiles();
  </script>
</body>
</html>

