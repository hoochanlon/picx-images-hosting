<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ä¸Šä¼ ç®¡ç† - picx-images-hosting</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/hoochanlon/fonts@refs/heads/main/public/OPPOSans4/result.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="./css/global.css" />
  <script src="./config.js"></script>
</head>
<body class="upload-page">
  <header class="upload-header">
    <h1>
      <span>ğŸ–¼ï¸</span>
      <span id="upload-title" style="cursor: pointer;">ä¸Šä¼ ç®¡ç†</span>
    </h1>
    <a href="index.html" class="back-link">
      <i class="fas fa-arrow-left"></i>
      è¿”å›é¦–é¡µ
    </a>
  </header>

  <div class="upload-container">
    <div class="upload-toolbar">
      <button id="create-folder-btn" class="btn-primary">
        <i class="fas fa-folder-plus"></i>
        æ–°å»ºæ–‡ä»¶å¤¹
      </button>
      <button id="upload-files-btn">
        <i class="fas fa-upload"></i>
        ä¸Šä¼ æ–‡ä»¶
      </button>
      <button id="settings-upload-path-btn" title="è®¾ç½®ä¸Šä¼ ç›®å½•">
        <i class="fas fa-cog"></i>
        è®¾ç½®ä¸Šä¼ ç›®å½•
      </button>
      <input type="file" id="file-input" multiple style="display: none;" />
    </div>

    <div class="upload-area" id="upload-area">
      <div class="upload-area-icon">ğŸ“¤</div>
      <div class="upload-area-text">æ‹–æ‹½æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹åˆ°è¿™é‡Œä¸Šä¼ </div>
      <div class="upload-area-hint">æ”¯æŒå¤šæ–‡ä»¶ä¸Šä¼ </div>
    </div>

    <div class="breadcrumb" id="breadcrumb">
      <div class="breadcrumb-item">
        <a href="#" data-path="">æ ¹ç›®å½•</a>
      </div>
    </div>

    <div class="file-browser">
      <ul class="file-list" id="file-list">
        <li class="empty-state">
          <div class="empty-state-icon">ğŸ“</div>
          <div>æ­£åœ¨åŠ è½½...</div>
        </li>
      </ul>
    </div>

    <div class="upload-progress" id="upload-progress" style="display: none;"></div>
  </div>

  <!-- åˆ›å»ºæ–‡ä»¶å¤¹æ¨¡æ€æ¡† -->
  <div class="modal" id="create-folder-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>æ–°å»ºæ–‡ä»¶å¤¹</h2>
        <button class="modal-close" data-close="create-folder">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>æ–‡ä»¶å¤¹è·¯å¾„ï¼š</label>
          <input type="text" id="folder-name-input" placeholder="ä¾‹å¦‚: folder æˆ– path/to/folder" />
          <div style="margin-top: 8px; font-size: 12px; color: #666;">
            <p>æç¤ºï¼š</p>
            <ul style="margin: 5px 0; padding-left: 20px;">
              <li>å¯ä»¥è¾“å…¥å•ä¸ªæ–‡ä»¶å¤¹åç§°ï¼Œå°†åœ¨å½“å‰ç›®å½•ä¸‹åˆ›å»º</li>
              <li>å¯ä»¥è¾“å…¥è·¯å¾„ï¼ˆå¦‚ path/to/folderï¼‰ï¼Œå°†åˆ›å»ºåµŒå¥—æ–‡ä»¶å¤¹ç»“æ„</li>
              <li>è·¯å¾„ä¸­çš„æ–œæ ä½¿ç”¨ "/" åˆ†éš”</li>
            </ul>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="create-folder">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-create-folder">åˆ›å»º</button>
      </div>
    </div>
  </div>

  <!-- è®¾ç½®ä¸Šä¼ ç›®å½•æ¨¡æ€æ¡† -->
  <div class="modal" id="settings-upload-path-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>è®¾ç½®ä¸Šä¼ ç›®å½•</h2>
        <button class="modal-close" data-close="settings-upload-path">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>ä¸Šä¼ ç›®å½•è·¯å¾„ï¼š</label>
          <input type="text" id="upload-path-input" placeholder="ä¾‹å¦‚: imgs/uploads/kate/" />
          <div style="margin-top: 10px; font-size: 12px; color: #666;">
            <p>æç¤ºï¼š</p>
            <ul style="margin: 5px 0; padding-left: 20px;">
              <li>ç•™ç©ºåˆ™ä½¿ç”¨å½“å‰æµè§ˆçš„ç›®å½•</li>
              <li>è·¯å¾„ä¼šè‡ªåŠ¨æ·»åŠ æœ«å°¾æ–œæ </li>
              <li>å¯ä»¥ä½¿ç”¨é¢åŒ…å±‘å¯¼èˆªé€‰æ‹©ç›®å½•åè®¾ç½®</li>
            </ul>
          </div>
        </div>
        <div class="form-group" style="margin-top: 15px;">
          <button class="btn-secondary" id="use-current-path-btn" style="margin-right: 10px;">ä½¿ç”¨å½“å‰ç›®å½•</button>
          <button class="btn-secondary" id="clear-upload-path-btn">æ¸…é™¤è®¾ç½®</button>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="settings-upload-path">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-settings-upload-path">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <!-- é‡å‘½åæ¨¡æ€æ¡† -->
  <div class="modal" id="rename-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>é‡å‘½å</h2>
        <button class="modal-close" data-close="rename">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>æ–°åç§°ï¼š</label>
          <input type="text" id="rename-input" placeholder="è¯·è¾“å…¥æ–°åç§°" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn-secondary" data-close="rename">å–æ¶ˆ</button>
        <button class="btn-primary" id="confirm-rename">ç¡®å®š</button>
      </div>
    </div>
  </div>

  <script>
    const REPO_OWNER = 'hoochanlon';
    const REPO_NAME = 'picx-images-hosting';
    const BRANCH = 'master';
    const PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}`;
    const CDN_BASE = `https://cdn.jsdelivr.net/gh/${REPO_OWNER}/${REPO_NAME}@${BRANCH}`;
    const IMAGE_EXT = /\.(jpe?g|png|gif|webp|svg)$/i;

    // è‡ªåŠ¨æ£€æµ‹ API åŸºç¡€åœ°å€
    // vercel dev è¿è¡Œæ—¶ï¼ˆlocalhost:3000ï¼‰ä½¿ç”¨æœ¬åœ° API
    // GitHub Pages å’Œè‡ªå®šä¹‰åŸŸåä½¿ç”¨ Vercel éƒ¨ç½²çš„ APIï¼ˆå› ä¸º GitHub Pages ä¸æ”¯æŒ Serverless Functionsï¼‰
    // Vercel éƒ¨ç½²ä½¿ç”¨å½“å‰åŸŸå
    const config = window.APP_CONFIG || {
      VERCEL_API_BASE: 'https://picx-images-hosting-brown.vercel.app',
      CUSTOM_DOMAINS: ['blog.hoochanlon.moe'],
      GITHUB_PAGES_PATTERN: /\.github\.io$/
    };
    
    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isVercelDev = isLocalhost && (window.location.port === '3000' || window.location.port === '3001');
    const isGitHubPages = config.GITHUB_PAGES_PATTERN.test(window.location.hostname);
    const isCustomDomain = config.CUSTOM_DOMAINS.includes(window.location.hostname);
    const VERCEL_API_BASE = config.VERCEL_API_BASE;
    
    const API_BASE = isLocalhost && !isVercelDev
      ? VERCEL_API_BASE
      : (isGitHubPages || isCustomDomain)
      ? VERCEL_API_BASE
      : window.location.origin;
    const API_ENDPOINT = `${API_BASE}/api/github`;

    let currentPath = '';
    let files = [];
    let folders = [];

    // DOM å…ƒç´ 
    const fileListEl = document.getElementById('file-list');
    const breadcrumbEl = document.getElementById('breadcrumb');
    const uploadAreaEl = document.getElementById('upload-area');
    const fileInputEl = document.getElementById('file-input');
    const uploadProgressEl = document.getElementById('upload-progress');
    const createFolderBtn = document.getElementById('create-folder-btn');
    const uploadFilesBtn = document.getElementById('upload-files-btn');
    const createFolderModal = document.getElementById('create-folder-modal');
    const renameModal = document.getElementById('rename-modal');
    const folderNameInput = document.getElementById('folder-name-input');
    const renameInput = document.getElementById('rename-input');

    // å·¥å…·å‡½æ•°
    async function toBase64(file) {
      const buffer = await file.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      let binary = '';
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }

    async function apiRequest(payload) {
      try {
        const res = await fetch(API_ENDPOINT, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        
        if (!res.ok) {
          let errorMessage = `API è¯·æ±‚å¤±è´¥: HTTP ${res.status}`;
          try {
            const errorData = await res.json();
            errorMessage = errorData.message || errorData.error || errorMessage;
          } catch (e) {
            const text = await res.text().catch(() => '');
            if (text) errorMessage = text;
          }
          throw new Error(errorMessage);
        }
        
        return res.json();
      } catch (err) {
        // å¤„ç†ç½‘ç»œé”™è¯¯
        if (err.name === 'TypeError' && err.message.includes('fetch')) {
          throw new Error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•');
        }
        throw err;
      }
    }

    async function fetchTree() {
      const url = `${API_BASE}/api/tree`;
      const res = await fetch(url);
      if (!res.ok) {
        const body = await res.json().catch(() => ({}));
        const hint = body.message || `HTTP ${res.status}`;
        throw new Error(`è·å–ä»“åº“æ ‘å¤±è´¥ï¼š${hint}`);
      }
      return res.json();
    }

    function buildPath(...parts) {
      const filtered = parts.filter(p => p && p.trim());
      if (filtered.length === 0) return '';
      // ç¡®ä¿è·¯å¾„æ ¼å¼æ­£ç¡®ï¼Œç§»é™¤å¤šä½™çš„æ–œæ 
      let path = filtered.join('/').replace(/\/+/g, '/');
      // ç§»é™¤å¼€å¤´çš„æ–œæ ï¼ˆGitHub API ä¸éœ€è¦ï¼‰
      if (path.startsWith('/')) {
        path = path.substring(1);
      }
      return path;
    }

    function getParentPath(path) {
      if (!path) return '';
      const parts = path.split('/').filter(p => p);
      parts.pop();
      return parts.join('/');
    }

    function updateBreadcrumb(path) {
      breadcrumbEl.innerHTML = '';
      const parts = path ? path.split('/').filter(p => p) : [];
      
      // æ ¹ç›®å½•
      const rootItem = document.createElement('div');
      rootItem.className = 'breadcrumb-item';
      const rootLink = document.createElement('a');
      rootLink.href = 'javascript:void(0)';
      rootLink.textContent = 'æ ¹ç›®å½•';
      rootLink.dataset.path = '';
      rootLink.style.cursor = 'pointer';
      rootLink.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('ç‚¹å‡»æ ¹ç›®å½•');
        navigateTo('');
        return false;
      });
      rootItem.appendChild(rootLink);
      breadcrumbEl.appendChild(rootItem);

      // è·¯å¾„éƒ¨åˆ†
      let breadcrumbPath = '';
      parts.forEach((part, index) => {
        const separator = document.createElement('span');
        separator.className = 'breadcrumb-separator';
        separator.textContent = ' / ';
        breadcrumbEl.appendChild(separator);

        breadcrumbPath = buildPath(breadcrumbPath, part);
        const item = document.createElement('div');
        item.className = 'breadcrumb-item';
        const link = document.createElement('a');
        link.href = 'javascript:void(0)';
        link.textContent = part;
        link.dataset.path = breadcrumbPath;
        link.style.cursor = 'pointer';
        
        // ä½¿ç”¨é—­åŒ…ä¿å­˜ breadcrumbPath çš„å€¼
        (function(path) {
          link.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('ç‚¹å‡»é¢åŒ…å±‘ç›®å½•:', part, 'è·¯å¾„:', path);
            console.log('å‡†å¤‡å¯¼èˆªï¼Œå½“å‰è·¯å¾„:', currentPath);
            navigateTo(path);
            return false;
          });
        })(breadcrumbPath);
        item.appendChild(link);
        breadcrumbEl.appendChild(item);
      });
    }

    function navigateTo(path) {
      console.log('å¯¼èˆªåˆ°è·¯å¾„:', path);
      console.log('å½“å‰è·¯å¾„ (å¯¼èˆªå‰):', currentPath);
      const normalizedPath = (path || '').trim();
      currentPath = normalizedPath;
      console.log('å½“å‰è·¯å¾„ (å¯¼èˆªå):', currentPath);
      updateBreadcrumb(currentPath);
      // ä½¿ç”¨ setTimeout ç¡®ä¿ currentPath å·²ç»æ›´æ–°
      setTimeout(() => {
        console.log('å¼€å§‹åŠ è½½æ–‡ä»¶ï¼Œå½“å‰è·¯å¾„åº”è¯¥æ˜¯:', currentPath);
        loadFiles();
      }, 0);
    }

    function renderFiles() {
      fileListEl.innerHTML = '';
      
      if (folders.length === 0 && files.length === 0) {
        fileListEl.innerHTML = `
          <li class="empty-state">
            <div class="empty-state-icon">ğŸ“</div>
            <div>å½“å‰ç›®å½•ä¸ºç©º</div>
          </li>
        `;
        return;
      }

      // æ˜¾ç¤ºæ–‡ä»¶å¤¹
      folders.forEach(folder => {
        const li = document.createElement('li');
        li.className = 'file-item';
        li.innerHTML = `
          <div class="file-icon"><i class="fas fa-folder"></i></div>
          <div class="file-name">${folder.name}</div>
          <div class="file-actions">
            <button class="btn-rename" data-type="folder" data-path="${folder.path}" title="é‡å‘½å">
              <i class="fas fa-edit"></i>
            </button>
            <button class="btn-delete btn-danger" data-type="folder" data-path="${folder.path}" title="åˆ é™¤">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        li.querySelector('.file-name').addEventListener('click', () => {
          navigateTo(folder.path);
        });
        
        li.querySelector('.btn-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          showRenameModal('folder', folder.path, folder.name);
        });
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteItem('folder', folder.path);
        });
        
        fileListEl.appendChild(li);
      });

      // æ˜¾ç¤ºæ–‡ä»¶
      files.forEach(file => {
        const li = document.createElement('li');
        li.className = 'file-item';
        const isImage = IMAGE_EXT.test(file.name);
        const pagesUrl = `${PAGES_BASE}/${file.path}`;
        const cdnUrl = `${CDN_BASE}/${file.path}`;
        
        li.innerHTML = `
          <div class="file-icon">
            <i class="fas ${isImage ? 'fa-image' : 'fa-file'}"></i>
          </div>
          <div class="file-name">${file.name}</div>
          <div class="file-actions">
            <button class="btn-copy-pages" data-url="${pagesUrl}" title="å¤åˆ¶ Pages é“¾æ¥">
              <i class="fas fa-link"></i>
            </button>
            <button class="btn-copy-cdn" data-url="${cdnUrl}" title="å¤åˆ¶ CDN é“¾æ¥">
              <i class="fas fa-cloud"></i>
            </button>
            <button class="btn-rename" data-type="file" data-path="${file.path}" title="é‡å‘½å">
              <i class="fas fa-edit"></i>
            </button>
            <button class="btn-delete btn-danger" data-type="file" data-path="${file.path}" title="åˆ é™¤">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `;
        
        // å¤åˆ¶ Pages é“¾æ¥
        li.querySelector('.btn-copy-pages').addEventListener('click', async (e) => {
          e.stopPropagation();
          const url = li.querySelector('.btn-copy-pages').dataset.url;
          try {
            await navigator.clipboard.writeText(url);
            const btn = li.querySelector('.btn-copy-pages');
            const originalTitle = btn.title;
            btn.title = 'å·²å¤åˆ¶';
            setTimeout(() => {
              btn.title = originalTitle;
            }, 1500);
          } catch (err) {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
          }
        });
        
        // å¤åˆ¶ CDN é“¾æ¥
        li.querySelector('.btn-copy-cdn').addEventListener('click', async (e) => {
          e.stopPropagation();
          const url = li.querySelector('.btn-copy-cdn').dataset.url;
          try {
            await navigator.clipboard.writeText(url);
            const btn = li.querySelector('.btn-copy-cdn');
            const originalTitle = btn.title;
            btn.title = 'å·²å¤åˆ¶';
            setTimeout(() => {
              btn.title = originalTitle;
            }, 1500);
          } catch (err) {
            console.error('å¤åˆ¶å¤±è´¥:', err);
            alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
          }
        });
        
        li.querySelector('.btn-rename').addEventListener('click', (e) => {
          e.stopPropagation();
          showRenameModal('file', file.path, file.name);
        });
        
        li.querySelector('.btn-delete').addEventListener('click', (e) => {
          e.stopPropagation();
          deleteItem('file', file.path);
        });
        
        fileListEl.appendChild(li);
      });
    }

    async function loadFiles() {
      try {
        fileListEl.innerHTML = '<li class="empty-state"><div>æ­£åœ¨åŠ è½½...</div></li>';
        const tree = await fetchTree();
        
        const allItems = (tree.tree || []).filter(item => item.type === 'blob' || item.type === 'tree');
        
        folders = [];
        files = [];
        
        console.log('åŠ è½½æ–‡ä»¶ï¼Œå½“å‰è·¯å¾„:', currentPath);
        
        // è§„èŒƒåŒ–å½“å‰è·¯å¾„
        const normalizedCurrentPath = (currentPath || '').trim();
        
        allItems.forEach(item => {
          const itemPath = item.path;
          
          if (item.type === 'tree') {
            // å¯¹äºæ–‡ä»¶å¤¹ï¼ˆtreeï¼‰ï¼Œæ£€æŸ¥å…¶çˆ¶ç›®å½•æ˜¯å¦ç­‰äºå½“å‰è·¯å¾„
            const itemDir = itemPath.includes('/') ? itemPath.slice(0, itemPath.lastIndexOf('/')) : '';
            const normalizedItemDir = (itemDir || '').trim();
            
            console.log(`æ£€æŸ¥æ–‡ä»¶å¤¹: ${itemPath}, çˆ¶ç›®å½•: "${normalizedItemDir}", å½“å‰è·¯å¾„: "${normalizedCurrentPath}"`);
            
            if (normalizedItemDir === normalizedCurrentPath) {
              folders.push({
                name: itemPath.split('/').pop(),
                path: itemPath
              });
            }
          } else {
            // å¯¹äºæ–‡ä»¶ï¼ˆblobï¼‰ï¼Œæ£€æŸ¥å…¶æ‰€åœ¨ç›®å½•æ˜¯å¦ç­‰äºå½“å‰è·¯å¾„
            const itemDir = itemPath.includes('/') ? itemPath.slice(0, itemPath.lastIndexOf('/')) : '';
            const normalizedItemDir = (itemDir || '').trim();
            
            console.log(`æ£€æŸ¥æ–‡ä»¶: ${itemPath}, æ‰€åœ¨ç›®å½•: "${normalizedItemDir}", å½“å‰è·¯å¾„: "${normalizedCurrentPath}"`);
            
            if (normalizedItemDir === normalizedCurrentPath) {
              files.push({
                name: itemPath.split('/').pop(),
                path: itemPath
              });
            }
          }
        });
        
        console.log('æ‰¾åˆ°çš„æ–‡ä»¶å¤¹:', folders.length, 'ä¸ª', folders);
        console.log('æ‰¾åˆ°çš„æ–‡ä»¶:', files.length, 'ä¸ª', files);
        
        folders.sort((a, b) => a.name.localeCompare(b.name));
        files.sort((a, b) => a.name.localeCompare(b.name));
        
        renderFiles();
      } catch (err) {
        console.error(err);
        fileListEl.innerHTML = `
          <li class="empty-state">
            <div class="empty-state-icon">âŒ</div>
            <div>åŠ è½½å¤±è´¥ï¼š${err.message}</div>
          </li>
        `;
      }
    }

    async function createFolder(nameOrPath) {
      if (!nameOrPath || !nameOrPath.trim()) {
        alert('è¯·è¾“å…¥æ–‡ä»¶å¤¹åç§°æˆ–è·¯å¾„');
        return;
      }
      
      let inputPath = nameOrPath.trim();
      
      // è§„èŒƒåŒ–è·¯å¾„ï¼šç§»é™¤å¼€å¤´çš„æ–œæ ï¼ˆå¦‚æœç”¨æˆ·è¾“å…¥äº†ç»å¯¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„ï¼‰
      if (inputPath.startsWith('/')) {
        inputPath = inputPath.substring(1);
      }
      
      // ç§»é™¤æœ«å°¾çš„æ–œæ ï¼ˆå¦‚æœæœ‰ï¼‰
      if (inputPath.endsWith('/')) {
        inputPath = inputPath.slice(0, -1);
      }
      
      // éªŒè¯è·¯å¾„æ ¼å¼ï¼ˆä¸èƒ½åŒ…å«éæ³•å­—ç¬¦ï¼‰
      if (inputPath.includes('..') || inputPath.includes('//')) {
        alert('è·¯å¾„æ ¼å¼ä¸æ­£ç¡®ï¼Œä¸èƒ½åŒ…å« ".." æˆ–è¿ç»­çš„æ–œæ ');
        return;
      }
      
      // æ„å»ºå®Œæ•´è·¯å¾„ï¼šæ€»æ˜¯ç›¸å¯¹äºå½“å‰ç›®å½•
      const folderPath = buildPath(currentPath, inputPath);
      
      // è§„èŒƒåŒ–æœ€ç»ˆè·¯å¾„
      let normalizedPath = folderPath.trim();
      if (normalizedPath.startsWith('/')) {
        normalizedPath = normalizedPath.substring(1);
      }
      
      if (!normalizedPath) {
        alert('è·¯å¾„ä¸èƒ½ä¸ºç©º');
        return;
      }
      
      console.log('åˆ›å»ºæ–‡ä»¶å¤¹è·¯å¾„:', normalizedPath);
      console.log('å½“å‰ç›®å½•:', currentPath);
      console.log('è¾“å…¥è·¯å¾„:', inputPath);
      
      // ä½¿ç”¨ ensureDirectoryExists æ¥åˆ›å»ºæ–‡ä»¶å¤¹ï¼ˆæ”¯æŒåˆ›å»ºåµŒå¥—æ–‡ä»¶å¤¹ï¼‰
      try {
        await ensureDirectoryExists(normalizedPath, 3);
        console.log('æ–‡ä»¶å¤¹åˆ›å»ºæˆåŠŸ:', normalizedPath);
        
        loadFiles();
        closeModal('create-folder');
        folderNameInput.value = '';
      } catch (err) {
        console.error('åˆ›å»ºæ–‡ä»¶å¤¹å¤±è´¥:', err);
        alert('åˆ›å»ºæ–‡ä»¶å¤¹å¤±è´¥ï¼š' + (err.message || 'æœªçŸ¥é”™è¯¯'));
      }
    }

    // ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆé€šè¿‡åˆ›å»º .gitkeep æ–‡ä»¶ï¼‰
    async function ensureDirectoryExists(dirPath, maxRetries = 3) {
      if (!dirPath || dirPath === '') return;
      
      // è§„èŒƒåŒ–è·¯å¾„ï¼šç§»é™¤å¼€å¤´çš„æ–œæ å’Œæœ«å°¾çš„æ–œæ 
      let normalizedPath = dirPath.trim();
      if (normalizedPath.startsWith('/')) {
        normalizedPath = normalizedPath.substring(1);
      }
      if (normalizedPath.endsWith('/')) {
        normalizedPath = normalizedPath.slice(0, -1);
      }
      
      // åˆ†å‰²è·¯å¾„ä¸ºå„ä¸ªéƒ¨åˆ†
      const parts = normalizedPath.split('/').filter(p => p);
      if (parts.length === 0) return;
      
      // é€’å½’åˆ›å»ºæ‰€æœ‰çˆ¶ç›®å½•
      let currentPath = '';
      for (let i = 0; i < parts.length; i++) {
        currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
        const gitkeepPath = `${currentPath}/.gitkeep`;
        
        // æ£€æŸ¥ç›®å½•æ˜¯å¦å·²å­˜åœ¨ï¼ˆå¢åŠ é‡è¯•æ¬¡æ•°å’Œç­‰å¾…æ—¶é—´ï¼‰
        let dirExists = false;
        for (let checkRetry = 0; checkRetry < 3; checkRetry++) {
          try {
            const checkRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
            if (checkRes.ok) {
              dirExists = true;
              console.log(`ç›®å½• ${currentPath} å·²å­˜åœ¨`);
              break;
            }
          } catch (e) {
            // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ›å»º
          }
          if (checkRetry < 2) {
            await new Promise(resolve => setTimeout(resolve, 1000 * (checkRetry + 1)));
          }
        }
        
        if (dirExists) {
          // ç›®å½•å·²å­˜åœ¨ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
          continue;
        }
        
        // å¦‚æœå½“å‰ä¸æ˜¯ç¬¬ä¸€ä¸ªç›®å½•ï¼Œç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
        if (i > 0) {
          const parentPath = parts.slice(0, i).join('/');
          await ensureDirectoryExists(parentPath, maxRetries);
        }
        
        // åˆ›å»º .gitkeep æ–‡ä»¶æ¥ç¡®ä¿ç›®å½•å­˜åœ¨ï¼ˆå¢åŠ é‡è¯•æœºåˆ¶ï¼‰
        let created = false;
        let lastError = null;
        
        for (let createRetry = 0; createRetry < maxRetries; createRetry++) {
          try {
            console.log(`åˆ›å»ºç›®å½• ${currentPath}ï¼Œè·¯å¾„: ${gitkeepPath} (å°è¯• ${createRetry + 1}/${maxRetries})`);
            const createResult = await apiRequest({
              action: 'upload',
              path: gitkeepPath,
              content: btoa(''),
              message: `Create directory: ${currentPath}/`
            });
            console.log(`ç›®å½• ${currentPath} åˆ›å»ºAPIè°ƒç”¨æˆåŠŸ:`, createResult);
            
            // éªŒè¯ç›®å½•æ˜¯å¦çœŸæ­£åˆ›å»ºæˆåŠŸï¼ˆå¢åŠ éªŒè¯é‡è¯•æ¬¡æ•°å’Œç­‰å¾…æ—¶é—´ï¼‰
            let verified = false;
            const verifyWaitTime = isLocalhost ? 2000 : 1500;
            const maxVerifyRetries = isLocalhost ? 8 : 6;
            
            for (let verifyRetry = 0; verifyRetry < maxVerifyRetries; verifyRetry++) {
              await new Promise(resolve => setTimeout(resolve, verifyWaitTime * (verifyRetry + 1)));
              try {
                const verifyRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
                console.log(`éªŒè¯ç›®å½• ${currentPath}ï¼Œå°è¯• ${verifyRetry + 1}/${maxVerifyRetries}ï¼ŒçŠ¶æ€: ${verifyRes.status}`);
                if (verifyRes.ok) {
                  verified = true;
                  console.log(`ç›®å½• ${currentPath} éªŒè¯æˆåŠŸ`);
                  break;
                } else {
                  const errorData = await verifyRes.json().catch(() => ({}));
                  console.log(`éªŒè¯å¤±è´¥ï¼Œå“åº”:`, errorData);
                }
              } catch (e) {
                console.log(`éªŒè¯ç›®å½• ${currentPath} å¤±è´¥:`, e);
              }
            }
            
            if (verified) {
              created = true;
              break;
            } else {
              console.warn(`ç›®å½• ${currentPath} åˆ›å»ºåéªŒè¯å¤±è´¥ï¼Œå°†é‡è¯•åˆ›å»º`);
            }
          } catch (err) {
            console.error(`åˆ›å»ºç›®å½• ${currentPath} å¤±è´¥ (å°è¯• ${createRetry + 1}/${maxRetries}):`, err);
            lastError = err;
            const errorMsg = err.message || '';
            
            // å¦‚æœé”™è¯¯æ˜¯ç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•å†æ¬¡åˆ›å»ºçˆ¶ç›®å½•
            if (errorMsg.includes('not be found') && i > 0) {
              const parentPath = parts.slice(0, i).join('/');
              console.log(`çˆ¶ç›®å½•ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»ºçˆ¶ç›®å½•: ${parentPath}`);
              await ensureDirectoryExists(parentPath, maxRetries);
              // ç­‰å¾…çˆ¶ç›®å½•ç”Ÿæ•ˆ
              await new Promise(resolve => setTimeout(resolve, isLocalhost ? 3000 : 2000));
            }
            
            // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•ï¼Œç­‰å¾…åç»§ç»­
            if (createRetry < maxRetries - 1) {
              await new Promise(resolve => setTimeout(resolve, isLocalhost ? 3000 : 2000));
            }
          }
        }
        
        if (!created) {
          const errorMsg = lastError ? lastError.message : 'æœªçŸ¥é”™è¯¯';
          throw new Error(`æ— æ³•åˆ›å»ºç›®å½• ${currentPath} (å·²é‡è¯• ${maxRetries} æ¬¡): ${errorMsg}`);
        }
      }
    }

    // è·å–å’Œä¿å­˜ä¸Šä¼ ç›®å½•è®¾ç½®
    function getUploadPath() {
      const saved = localStorage.getItem('uploadPath');
      return saved || '';
    }

    function saveUploadPath(path) {
      if (path && path.trim()) {
        localStorage.setItem('uploadPath', path.trim());
      } else {
        localStorage.removeItem('uploadPath');
      }
    }

    async function uploadFiles(fileList, basePath = '') {
      // ä¼˜å…ˆçº§ï¼šbasePath > è®¾ç½®çš„ä¸Šä¼ ç›®å½• > å½“å‰æµè§ˆç›®å½• > é»˜è®¤ç›®å½•
      let targetPath = basePath || getUploadPath() || currentPath || 'imgs/uploads/kate/';
      // ç¡®ä¿è·¯å¾„æ ¼å¼æ­£ç¡®
      if (targetPath && !targetPath.endsWith('/')) {
        targetPath += '/';
      }
      const filesArray = Array.from(fileList);
      
      if (filesArray.length === 0) return;
      
      uploadProgressEl.style.display = 'block';
      uploadProgressEl.innerHTML = '';
      
      // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼ˆæœ‰ webkitRelativePathï¼‰
      const isFolderUpload = filesArray.some(file => file.webkitRelativePath);
      
      // å¦‚æœæ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œå…ˆæ”¶é›†æ‰€æœ‰éœ€è¦çš„ç›®å½•å¹¶åˆ›å»º
      if (isFolderUpload) {
        console.log('æ£€æµ‹åˆ°æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œå…ˆåˆ›å»ºæ‰€æœ‰ç›®å½•...');
        const dirsToCreate = new Set();
        
        // æ”¶é›†æ‰€æœ‰éœ€è¦çš„ç›®å½•ï¼ˆåŒ…æ‹¬æ‰€æœ‰çˆ¶ç›®å½•ï¼‰
        filesArray.forEach(file => {
          if (file.webkitRelativePath) {
            const filePath = buildPath(targetPath, file.webkitRelativePath);
            const fileDir = getParentPath(filePath);
            if (fileDir && fileDir !== '') {
              // è§„èŒƒåŒ–è·¯å¾„
              let normalizedDir = fileDir.trim();
              if (normalizedDir.startsWith('/')) {
                normalizedDir = normalizedDir.substring(1);
              }
              if (normalizedDir.endsWith('/')) {
                normalizedDir = normalizedDir.slice(0, -1);
              }
              
              // æ”¶é›†æ‰€æœ‰çˆ¶ç›®å½•
              const dirParts = normalizedDir.split('/').filter(p => p);
              let currentDir = '';
              dirParts.forEach(part => {
                currentDir = currentDir ? `${currentDir}/${part}` : part;
                dirsToCreate.add(currentDir);
              });
            }
          }
        });
        
        // æŒ‰è·¯å¾„æ·±åº¦æ’åºï¼Œç¡®ä¿å…ˆåˆ›å»ºçˆ¶ç›®å½•
        const sortedDirs = Array.from(dirsToCreate).sort((a, b) => {
          const depthA = a.split('/').length;
          const depthB = b.split('/').length;
          return depthA - depthB;
        });
        
        console.log(`éœ€è¦åˆ›å»ºçš„ç›®å½• (å…± ${sortedDirs.length} ä¸ª):`, sortedDirs);
        
        // åˆ›å»ºæ‰€æœ‰ç›®å½•ï¼ˆå¢åŠ é‡è¯•æ¬¡æ•°ï¼‰
        for (let dirIndex = 0; dirIndex < sortedDirs.length; dirIndex++) {
          const dir = sortedDirs[dirIndex];
          console.log(`åˆ›å»ºç›®å½• ${dirIndex + 1}/${sortedDirs.length}: ${dir}`);
          try {
            await ensureDirectoryExists(dir, 3);
            console.log(`ç›®å½• ${dir} åˆ›å»ºæˆåŠŸ`);
          } catch (err) {
            console.error(`ç›®å½• ${dir} åˆ›å»ºå¤±è´¥:`, err);
            // ç»§ç»­å°è¯•åˆ›å»ºå…¶ä»–ç›®å½•ï¼Œä½†è®°å½•é”™è¯¯
          }
          // æ¯ä¸ªç›®å½•åˆ›å»ºåç¨ä½œç­‰å¾…ï¼Œé¿å…APIé™æµ
          if (dirIndex < sortedDirs.length - 1) {
            await new Promise(resolve => setTimeout(resolve, isLocalhost ? 500 : 300));
          }
        }
        
        console.log('æ‰€æœ‰ç›®å½•åˆ›å»ºå®Œæˆï¼Œç­‰å¾…ç”Ÿæ•ˆ...');
        // ç­‰å¾…ç›®å½•ç”Ÿæ•ˆï¼ˆåœ¨vercel devç¯å¢ƒä¸‹å¢åŠ ç­‰å¾…æ—¶é—´ï¼‰
        const waitTime = isLocalhost ? 10000 : 5000;
        await new Promise(resolve => setTimeout(resolve, waitTime));
        console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶...');
      }
      
      for (let i = 0; i < filesArray.length; i++) {
        const file = filesArray[i];
        const progressItem = document.createElement('div');
        progressItem.className = 'progress-item';
        const displayName = file.webkitRelativePath || file.name;
        progressItem.innerHTML = `
          <div class="file-name">${displayName}</div>
          <div class="progress-bar">
            <div class="progress-fill" style="width: 0%"></div>
          </div>
          <div class="progress-text">0%</div>
        `;
        uploadProgressEl.appendChild(progressItem);
        
        const progressFill = progressItem.querySelector('.progress-fill');
        const progressText = progressItem.querySelector('.progress-text');
        
        try {
          const content = await toBase64(file);
          
          // æ„å»ºæ–‡ä»¶è·¯å¾„
          let filePath;
          if (file.webkitRelativePath) {
            // æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„
            filePath = buildPath(targetPath, file.webkitRelativePath);
          } else {
            // æ™®é€šæ–‡ä»¶ä¸Šä¼ 
            filePath = buildPath(targetPath, file.name);
          }
          
          if (!filePath) {
            throw new Error('æ–‡ä»¶è·¯å¾„ä¸èƒ½ä¸ºç©º');
          }
          
          // å¦‚æœä¸æ˜¯æ–‡ä»¶å¤¹ä¸Šä¼ ï¼Œç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
          if (!isFolderUpload) {
            const fileDir = getParentPath(filePath);
            if (fileDir && fileDir !== '') {
              console.log('ç¡®ä¿ç›®å½•å­˜åœ¨:', fileDir);
              await ensureDirectoryExists(fileDir, 3);
              // åœ¨vercel devç¯å¢ƒä¸‹å¢åŠ ç­‰å¾…æ—¶é—´
              await new Promise(resolve => setTimeout(resolve, isLocalhost ? 4000 : 2000));
            }
          } else {
            // æ–‡ä»¶å¤¹ä¸Šä¼ æ—¶ï¼Œå†æ¬¡ç¡®ä¿æ–‡ä»¶æ‰€åœ¨ç›®å½•å­˜åœ¨ï¼ˆå¯èƒ½è¿˜æœ‰å­ç›®å½•ï¼‰
            const fileDir = getParentPath(filePath);
            if (fileDir && fileDir !== '') {
              // è§„èŒƒåŒ–è·¯å¾„
              let normalizedDir = fileDir.trim();
              if (normalizedDir.startsWith('/')) {
                normalizedDir = normalizedDir.substring(1);
              }
              if (normalizedDir.endsWith('/')) {
                normalizedDir = normalizedDir.slice(0, -1);
              }
              
              // æ£€æŸ¥ç›®å½•æ˜¯å¦å·²åˆ›å»ºï¼ˆå¯èƒ½ä¹‹å‰æ¼æ‰äº†ï¼‰
              const gitkeepPath = `${normalizedDir}/.gitkeep`;
              let dirExists = false;
              try {
                const checkRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
                if (checkRes.ok) {
                  dirExists = true;
                }
              } catch (e) {
                // ç›®å½•ä¸å­˜åœ¨ï¼Œéœ€è¦åˆ›å»º
              }
              
              if (!dirExists) {
                console.log('æ£€æµ‹åˆ°æœªåˆ›å»ºçš„ç›®å½•ï¼Œç«‹å³åˆ›å»º:', normalizedDir);
                await ensureDirectoryExists(normalizedDir, 3);
                // ç­‰å¾…ç›®å½•ç”Ÿæ•ˆ
                await new Promise(resolve => setTimeout(resolve, isLocalhost ? 5000 : 3000));
              }
            }
          }
          
          console.log('å¼€å§‹ä¸Šä¼ æ–‡ä»¶:', filePath);
          
          // ç›´æ¥è°ƒç”¨ API ä»¥è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
          const uploadRes = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'upload',
              path: filePath,
              content: content,
              message: `Upload: ${filePath}`
            }),
          });
          
          if (!uploadRes.ok) {
            const errorData = await uploadRes.json().catch(() => ({}));
            console.error('ä¸Šä¼ å¤±è´¥ï¼ŒAPI å“åº”:', errorData);
            const errorMsg = errorData.message || errorData.error || `HTTP ${uploadRes.status}`;
            throw new Error(errorMsg);
          }
          
          const uploadResult = await uploadRes.json();
          console.log('ä¸Šä¼ æˆåŠŸ:', uploadResult);
          
          progressFill.style.width = '100%';
          progressText.textContent = 'å®Œæˆ';
          progressItem.style.opacity = '0.6';
        } catch (err) {
          console.error('ä¸Šä¼ å¤±è´¥:', err);
          // æä¾›æ›´å‹å¥½çš„é”™è¯¯æç¤º
          let errorMsg = err.message || 'ä¸Šä¼ å¤±è´¥';
          if (errorMsg.includes('not be found')) {
            // å°è¯•åˆ›å»ºç›®å½•åé‡è¯•
            try {
              // å…ˆæ„å»ºæ–‡ä»¶è·¯å¾„å’Œç›®å½•è·¯å¾„
              const retryFilePath = buildPath(targetPath, file.webkitRelativePath || file.name);
              const retryFileDir = getParentPath(retryFilePath);
              
              if (!retryFileDir || retryFileDir === '') {
                throw new Error('æ— æ³•ç¡®å®šæ–‡ä»¶ç›®å½•è·¯å¾„');
              }
              
              // è§„èŒƒåŒ–è·¯å¾„
              let normalizedDir = retryFileDir.trim();
              if (normalizedDir.startsWith('/')) {
                normalizedDir = normalizedDir.substring(1);
              }
              if (normalizedDir.endsWith('/')) {
                normalizedDir = normalizedDir.slice(0, -1);
              }
              
              console.log('ä¸Šä¼ å¤±è´¥ï¼Œå°è¯•åˆ›å»ºç›®å½•åé‡è¯•:', normalizedDir);
              await ensureDirectoryExists(normalizedDir, 3);
              console.log('ç›®å½•åˆ›å»ºæˆåŠŸï¼ŒéªŒè¯ç›®å½•å­˜åœ¨...');
              
              // éªŒè¯ç›®å½•ç¡®å®å­˜åœ¨ï¼ˆå¢åŠ éªŒè¯æ¬¡æ•°å’Œç­‰å¾…æ—¶é—´ï¼‰
              const gitkeepPath = `${normalizedDir}/.gitkeep`;
              console.log('éªŒè¯ç›®å½•ï¼Œæ£€æŸ¥è·¯å¾„:', gitkeepPath);
              let dirVerified = false;
              const verifyWaitTime = isLocalhost ? 2000 : 1500;
              const maxVerifyRetries = isLocalhost ? 8 : 6;
              
              for (let verifyRetry = 0; verifyRetry < maxVerifyRetries; verifyRetry++) {
                await new Promise(resolve => setTimeout(resolve, verifyWaitTime * (verifyRetry + 1)));
                try {
                  const verifyRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
                  console.log(`éªŒè¯å°è¯• ${verifyRetry + 1}/${maxVerifyRetries}ï¼ŒçŠ¶æ€: ${verifyRes.status}`);
                  if (verifyRes.ok) {
                    dirVerified = true;
                    console.log('ç›®å½•éªŒè¯æˆåŠŸï¼Œå¼€å§‹é‡è¯•ä¸Šä¼ ');
                    break;
                  } else {
                    const errorData = await verifyRes.json().catch(() => ({}));
                    console.log('éªŒè¯å¤±è´¥ï¼Œå“åº”:', errorData);
                  }
                } catch (e) {
                  console.log(`ç›®å½•éªŒè¯é‡è¯• ${verifyRetry + 1}/${maxVerifyRetries}ï¼Œé”™è¯¯:`, e);
                }
              }
              
              if (!dirVerified) {
                throw new Error('ç›®å½•åˆ›å»ºåéªŒè¯å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
              }
              
              // é¢å¤–ç­‰å¾…ï¼Œç¡®ä¿ç›®å½•å®Œå…¨ç”Ÿæ•ˆ
              console.log('ç­‰å¾…ç›®å½•å®Œå…¨ç”Ÿæ•ˆ...');
              await new Promise(resolve => setTimeout(resolve, isLocalhost ? 6000 : 4000));
              
              console.log('é‡è¯•ä¸Šä¼ æ–‡ä»¶:', retryFilePath);
              const retryContent = await toBase64(file);
              
              // ç›´æ¥è°ƒç”¨ API ä»¥è·å–æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
              const uploadRes = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  action: 'upload',
                  path: retryFilePath,
                  content: retryContent,
                  message: `Upload: ${retryFilePath}`
                }),
              });
              
              if (!uploadRes.ok) {
                const errorData = await uploadRes.json().catch(() => ({}));
                console.error('ä¸Šä¼ å¤±è´¥ï¼ŒAPI å“åº”:', errorData);
                console.error('ä¸Šä¼ è·¯å¾„:', retryFilePath);
                console.error('HTTP çŠ¶æ€:', uploadRes.status);
                const retryErrorMsg = errorData.message || errorData.error || `HTTP ${uploadRes.status}`;
                throw new Error(retryErrorMsg);
              }
              
              const uploadResult = await uploadRes.json();
              console.log('é‡è¯•ä¸Šä¼ æˆåŠŸ:', uploadResult);
              
              progressFill.style.width = '100%';
              progressText.textContent = 'å®Œæˆ';
              progressItem.style.opacity = '0.6';
              continue; // æˆåŠŸï¼Œç»§ç»­ä¸‹ä¸€ä¸ªæ–‡ä»¶
            } catch (retryErr) {
              console.error('ç›®å½•åˆ›å»ºæˆ–é‡è¯•ä¸Šä¼ å¤±è´¥:', retryErr);
              errorMsg = `ç›®å½•åˆ›å»ºå¤±è´¥: ${retryErr.message || 'è¯·æ£€æŸ¥è·¯å¾„æ˜¯å¦æ­£ç¡®'}`;
            }
          } else if (errorMsg.includes('already exists')) {
            errorMsg = 'æ–‡ä»¶å·²å­˜åœ¨ï¼Œè¯·é‡å‘½ååé‡è¯•';
          }
          progressText.textContent = 'å¤±è´¥ï¼š' + errorMsg;
          progressItem.style.color = '#cf222e';
        }
      }
      
      setTimeout(() => {
        loadFiles();
        setTimeout(() => {
          uploadProgressEl.style.display = 'none';
          uploadProgressEl.innerHTML = '';
        }, 2000);
      }, 1000);
    }

    function showRenameModal(type, path, currentName) {
      renameInput.value = currentName;
      renameInput.dataset.type = type;
      renameInput.dataset.path = path;
      showModal('rename');
    }

    async function renameItem(type, oldPath, newName) {
      if (!newName || !newName.trim()) {
        alert('è¯·è¾“å…¥æ–°åç§°');
        return;
      }
      
      const parentPath = getParentPath(oldPath);
      const newPath = buildPath(parentPath, newName.trim());
      
      if (type === 'folder') {
        // æ–‡ä»¶å¤¹é‡å‘½åéœ€è¦ç§»åŠ¨æ‰€æœ‰æ–‡ä»¶
        alert('æ–‡ä»¶å¤¹é‡å‘½ååŠŸèƒ½éœ€è¦ç§»åŠ¨æ‰€æœ‰æ–‡ä»¶ï¼Œæ­¤åŠŸèƒ½è¾ƒå¤æ‚ï¼Œå»ºè®®æ‰‹åŠ¨æ“ä½œ');
        return;
      }
      
      try {
        // è·å–åŸæ–‡ä»¶å†…å®¹
        const fileRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(oldPath)}`);
        const fileData = await fileRes.json();
        
        // åˆ›å»ºæ–°æ–‡ä»¶
        await apiRequest({
          action: 'upload',
          path: newPath,
          content: fileData.content,
          message: `Rename: ${oldPath} -> ${newPath}`
        });
        
        // åˆ é™¤åŸæ–‡ä»¶
        await apiRequest({
          action: 'delete',
          path: oldPath,
          sha: fileData.sha,
          message: `Delete old file: ${oldPath}`
        });
        
        loadFiles();
        closeModal('rename');
      } catch (err) {
        console.error(err);
        alert('é‡å‘½åå¤±è´¥ï¼š' + err.message);
      }
    }

    // é€’å½’åˆ é™¤æ–‡ä»¶å¤¹åŠå…¶æ‰€æœ‰å†…å®¹
    async function deleteFolder(folderPath) {
      console.log('å¼€å§‹åˆ é™¤æ–‡ä»¶å¤¹:', folderPath);
      
      // è§„èŒƒåŒ–æ–‡ä»¶å¤¹è·¯å¾„
      let normalizedPath = folderPath.trim();
      if (normalizedPath.endsWith('/')) {
        normalizedPath = normalizedPath.slice(0, -1);
      }
      
      // è·å–æ‰€æœ‰æ–‡ä»¶æ ‘
      const tree = await fetchTree();
      const allItems = (tree.tree || []).filter(item => item.type === 'blob' || item.type === 'tree');
      
      // æ‰¾åˆ°æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œç›´æ¥å­æ–‡ä»¶å¤¹ï¼ˆä¸åŒ…æ‹¬åµŒå¥—å†…å®¹ï¼‰
      const directItems = allItems.filter(item => {
        const itemPath = item.path;
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶å¤¹çš„ç›´æ¥å­é¡¹ï¼ˆä¸æ˜¯åµŒå¥—çš„ï¼‰
        if (!itemPath.startsWith(normalizedPath + '/')) {
          return false;
        }
        // è·å–ç›¸å¯¹äºæ–‡ä»¶å¤¹çš„è·¯å¾„
        const relativePath = itemPath.substring(normalizedPath.length + 1);
        // å¦‚æœæ˜¯ç›´æ¥å­é¡¹ï¼Œç›¸å¯¹è·¯å¾„ä¸­ä¸åº”è¯¥å†æœ‰æ–œæ 
        return !relativePath.includes('/');
      });
      
      console.log(`æ‰¾åˆ° ${directItems.length} ä¸ªç›´æ¥å­é¡¹éœ€è¦åˆ é™¤`);
      
      if (directItems.length === 0) {
        // æ–‡ä»¶å¤¹ä¸ºç©ºï¼Œåªåˆ é™¤ .gitkeep æ–‡ä»¶
        const gitkeepPath = `${normalizedPath}/.gitkeep`;
        try {
          const gitkeepRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
          if (gitkeepRes.ok) {
            const gitkeepData = await gitkeepRes.json();
            if (gitkeepData.sha) {
              await apiRequest({
                action: 'delete',
                path: gitkeepPath,
                sha: gitkeepData.sha,
                message: `Delete folder: ${normalizedPath}`
              });
              console.log('å·²åˆ é™¤ç©ºæ–‡ä»¶å¤¹:', normalizedPath);
            }
          }
        } catch (err) {
          console.warn('åˆ é™¤ .gitkeep å¤±è´¥ï¼ˆå¯èƒ½ä¸å­˜åœ¨ï¼‰:', err);
        }
        return;
      }
      
      // å…ˆåˆ é™¤æ‰€æœ‰æ–‡ä»¶ï¼Œå†åˆ é™¤å­æ–‡ä»¶å¤¹ï¼ˆå­æ–‡ä»¶å¤¹ä¼šé€’å½’åˆ é™¤å…¶å†…å®¹ï¼‰
      const filesToDelete = directItems.filter(item => item.type === 'blob');
      const foldersToDelete = directItems.filter(item => item.type === 'tree');
      
      // åˆ é™¤æ‰€æœ‰æ–‡ä»¶
      let deletedCount = 0;
      let failedItems = [];
      
      for (const item of filesToDelete) {
        try {
          const fileRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(item.path)}`);
          if (fileRes.ok) {
            const fileData = await fileRes.json();
            if (fileData.sha) {
              await apiRequest({
                action: 'delete',
                path: item.path,
                sha: fileData.sha,
                message: `Delete: ${item.path}`
              });
              deletedCount++;
              console.log(`å·²åˆ é™¤æ–‡ä»¶: ${item.path}`);
            }
          }
          // æ¯ä¸ªåˆ é™¤æ“ä½œåç¨ä½œç­‰å¾…ï¼Œé¿å…APIé™æµ
          await new Promise(resolve => setTimeout(resolve, 200));
        } catch (err) {
          console.error(`åˆ é™¤å¤±è´¥: ${item.path}`, err);
          failedItems.push({ path: item.path, error: err.message });
        }
      }
      
      // é€’å½’åˆ é™¤æ‰€æœ‰å­æ–‡ä»¶å¤¹
      for (const item of foldersToDelete) {
        try {
          await deleteFolder(item.path);
          deletedCount++;
          console.log(`å·²åˆ é™¤å­æ–‡ä»¶å¤¹: ${item.path}`);
          // æ¯ä¸ªåˆ é™¤æ“ä½œåç¨ä½œç­‰å¾…ï¼Œé¿å…APIé™æµ
          await new Promise(resolve => setTimeout(resolve, 200));
        } catch (err) {
          console.error(`åˆ é™¤å­æ–‡ä»¶å¤¹å¤±è´¥: ${item.path}`, err);
          failedItems.push({ path: item.path, error: err.message });
        }
      }
      
      // æœ€ååˆ é™¤æ–‡ä»¶å¤¹æœ¬èº«çš„ .gitkeep æ–‡ä»¶
      try {
        const gitkeepPath = `${normalizedPath}/.gitkeep`;
        const gitkeepRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(gitkeepPath)}`);
        if (gitkeepRes.ok) {
          const gitkeepData = await gitkeepRes.json();
          if (gitkeepData.sha) {
            await apiRequest({
              action: 'delete',
              path: gitkeepPath,
              sha: gitkeepData.sha,
              message: `Delete folder: ${normalizedPath}`
            });
            console.log('å·²åˆ é™¤æ–‡ä»¶å¤¹ .gitkeep:', normalizedPath);
          }
        }
      } catch (err) {
        console.warn('åˆ é™¤ .gitkeep å¤±è´¥ï¼ˆå¯èƒ½ä¸å­˜åœ¨ï¼‰:', err);
      }
      
      if (failedItems.length > 0) {
        const failedPaths = failedItems.map(item => item.path).join('\n');
        throw new Error(`éƒ¨åˆ†é¡¹ç›®åˆ é™¤å¤±è´¥:\n${failedPaths}`);
      }
      
      console.log(`æ–‡ä»¶å¤¹åˆ é™¤å®Œæˆ: ${normalizedPath}ï¼Œå…±åˆ é™¤ ${deletedCount} ä¸ªé¡¹ç›®`);
    }

    async function deleteItem(type, path) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤${type === 'folder' ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶'} "${path}" å—ï¼Ÿ${type === 'folder' ? '\n\næ³¨æ„ï¼šå°†åˆ é™¤æ–‡ä»¶å¤¹åŠå…¶æ‰€æœ‰å†…å®¹ï¼' : ''}`)) {
        return;
      }
      
      try {
        if (type === 'file') {
          // è·å–æ–‡ä»¶ä¿¡æ¯
          const fileRes = await fetch(`${API_BASE}/api/file?path=${encodeURIComponent(path)}`);
          if (!fileRes.ok) {
            const errorData = await fileRes.json().catch(() => ({}));
            throw new Error(errorData.message || `è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: HTTP ${fileRes.status}`);
          }
          
          const fileData = await fileRes.json();
          if (!fileData.sha) {
            throw new Error('æ— æ³•è·å–æ–‡ä»¶ SHAï¼Œæ–‡ä»¶å¯èƒ½ä¸å­˜åœ¨');
          }
          
          // æ‰§è¡Œåˆ é™¤
          await apiRequest({
            action: 'delete',
            path: path,
            sha: fileData.sha,
            message: `Delete: ${path}`
          });
        } else {
          // åˆ é™¤æ–‡ä»¶å¤¹ï¼šéœ€è¦åˆ é™¤æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œå­æ–‡ä»¶å¤¹
          await deleteFolder(path);
        }
        
        loadFiles();
      } catch (err) {
        console.error('åˆ é™¤å¤±è´¥:', err);
        const errorMessage = err.message || 'åˆ é™¤å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•';
        alert('åˆ é™¤å¤±è´¥ï¼š' + errorMessage);
      }
    }

    function showModal(modalId) {
      document.getElementById(`${modalId}-modal`).classList.add('show');
    }

    function closeModal(modalId) {
      document.getElementById(`${modalId}-modal`).classList.remove('show');
    }

    // äº‹ä»¶ç›‘å¬
    createFolderBtn.addEventListener('click', () => {
      folderNameInput.value = '';
      showModal('create-folder');
    });

    document.getElementById('confirm-create-folder').addEventListener('click', () => {
      createFolder(folderNameInput.value);
    });

    document.getElementById('confirm-rename').addEventListener('click', () => {
      const type = renameInput.dataset.type;
      const path = renameInput.dataset.path;
      renameItem(type, path, renameInput.value);
    });

    uploadFilesBtn.addEventListener('click', () => {
      fileInputEl.click();
    });


    // è®¾ç½®ä¸Šä¼ ç›®å½•ç›¸å…³
    const settingsUploadPathBtn = document.getElementById('settings-upload-path-btn');
    const uploadPathInput = document.getElementById('upload-path-input');
    const useCurrentPathBtn = document.getElementById('use-current-path-btn');
    const clearUploadPathBtn = document.getElementById('clear-upload-path-btn');
    const confirmSettingsUploadPathBtn = document.getElementById('confirm-settings-upload-path');

    function saveUploadPath(path) {
      if (path && path.trim()) {
        localStorage.setItem('uploadPath', path.trim());
      } else {
        localStorage.removeItem('uploadPath');
      }
    }

    // åŠ è½½ä¿å­˜çš„ä¸Šä¼ ç›®å½•è®¾ç½®
    const savedUploadPath = getUploadPath();
    if (savedUploadPath && uploadPathInput) {
      uploadPathInput.value = savedUploadPath;
    }

    if (settingsUploadPathBtn) {
      settingsUploadPathBtn.addEventListener('click', () => {
        // æ‰“å¼€æ¨¡æ€æ¡†æ—¶ï¼Œæ˜¾ç¤ºå½“å‰è®¾ç½®æˆ–å½“å‰æµè§ˆçš„ç›®å½•
        const currentSaved = getUploadPath();
        if (uploadPathInput) {
          uploadPathInput.value = currentSaved || currentPath || '';
        }
        showModal('settings-upload-path');
      });
    }

    if (useCurrentPathBtn) {
      useCurrentPathBtn.addEventListener('click', () => {
        if (uploadPathInput) {
          uploadPathInput.value = currentPath || '';
        }
      });
    }

    if (clearUploadPathBtn) {
      clearUploadPathBtn.addEventListener('click', () => {
        if (uploadPathInput) {
          uploadPathInput.value = '';
        }
        saveUploadPath('');
        alert('å·²æ¸…é™¤ä¸Šä¼ ç›®å½•è®¾ç½®');
      });
    }

    if (confirmSettingsUploadPathBtn) {
      confirmSettingsUploadPathBtn.addEventListener('click', () => {
        const path = uploadPathInput ? uploadPathInput.value.trim() : '';
        saveUploadPath(path);
        closeModal('settings-upload-path');
        alert('ä¸Šä¼ ç›®å½•è®¾ç½®å·²ä¿å­˜ï¼š' + (path || 'ä½¿ç”¨å½“å‰æµè§ˆç›®å½•'));
      });
    }

    fileInputEl.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        uploadFiles(e.target.files);
        e.target.value = '';
      }
    });


    // æ‹–æ‹½ä¸Šä¼ 
    uploadAreaEl.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadAreaEl.classList.add('dragover');
    });

    uploadAreaEl.addEventListener('dragleave', () => {
      uploadAreaEl.classList.remove('dragover');
    });

    uploadAreaEl.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadAreaEl.classList.remove('dragover');
      
      const files = Array.from(e.dataTransfer.files);
      if (files.length > 0) {
        uploadFiles(files);
      }
    });

    // æ¨¡æ€æ¡†å…³é—­
    document.querySelectorAll('[data-close]').forEach(btn => {
      btn.addEventListener('click', () => {
        const modalId = btn.dataset.close;
        closeModal(modalId);
      });
    });

    // æ ‡é¢˜ç‚¹å‡»å®Œå…¨åˆ·æ–°
    const uploadTitle = document.getElementById('upload-title');
    uploadTitle.addEventListener('click', () => {
      // é‡ç½®åˆ°æ ¹ç›®å½•
      currentPath = '';
      updateBreadcrumb(currentPath);
      loadFiles();
    });

    // åˆå§‹åŒ–
    // ç¡®ä¿åˆå§‹é¢åŒ…å±‘æ­£ç¡®è®¾ç½®
    updateBreadcrumb(currentPath);
    loadFiles();
  </script>
</body>
</html>